// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: embedded_sass.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019 Google Inc. Use of this source code is governed by an
// MIT-style license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The wrapper type for all messages sent from the host to the compiler. This
/// provides a `oneof` that makes it possible to determine the type of each
/// inbound message.
struct Sass_EmbeddedProtocol_InboundMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The wrapped message. Mandatory.
  var message: Sass_EmbeddedProtocol_InboundMessage.OneOf_Message? = nil

  var compileRequest: Sass_EmbeddedProtocol_InboundMessage.CompileRequest {
    get {
      if case .compileRequest(let v)? = message {return v}
      return Sass_EmbeddedProtocol_InboundMessage.CompileRequest()
    }
    set {message = .compileRequest(newValue)}
  }

  var canonicalizeResponse: Sass_EmbeddedProtocol_InboundMessage.CanonicalizeResponse {
    get {
      if case .canonicalizeResponse(let v)? = message {return v}
      return Sass_EmbeddedProtocol_InboundMessage.CanonicalizeResponse()
    }
    set {message = .canonicalizeResponse(newValue)}
  }

  var importResponse: Sass_EmbeddedProtocol_InboundMessage.ImportResponse {
    get {
      if case .importResponse(let v)? = message {return v}
      return Sass_EmbeddedProtocol_InboundMessage.ImportResponse()
    }
    set {message = .importResponse(newValue)}
  }

  var fileImportResponse: Sass_EmbeddedProtocol_InboundMessage.FileImportResponse {
    get {
      if case .fileImportResponse(let v)? = message {return v}
      return Sass_EmbeddedProtocol_InboundMessage.FileImportResponse()
    }
    set {message = .fileImportResponse(newValue)}
  }

  var functionCallResponse: Sass_EmbeddedProtocol_InboundMessage.FunctionCallResponse {
    get {
      if case .functionCallResponse(let v)? = message {return v}
      return Sass_EmbeddedProtocol_InboundMessage.FunctionCallResponse()
    }
    set {message = .functionCallResponse(newValue)}
  }

  var versionRequest: Sass_EmbeddedProtocol_InboundMessage.VersionRequest {
    get {
      if case .versionRequest(let v)? = message {return v}
      return Sass_EmbeddedProtocol_InboundMessage.VersionRequest()
    }
    set {message = .versionRequest(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The wrapped message. Mandatory.
  enum OneOf_Message: Equatable {
    case compileRequest(Sass_EmbeddedProtocol_InboundMessage.CompileRequest)
    case canonicalizeResponse(Sass_EmbeddedProtocol_InboundMessage.CanonicalizeResponse)
    case importResponse(Sass_EmbeddedProtocol_InboundMessage.ImportResponse)
    case fileImportResponse(Sass_EmbeddedProtocol_InboundMessage.FileImportResponse)
    case functionCallResponse(Sass_EmbeddedProtocol_InboundMessage.FunctionCallResponse)
    case versionRequest(Sass_EmbeddedProtocol_InboundMessage.VersionRequest)

  #if !swift(>=4.1)
    static func ==(lhs: Sass_EmbeddedProtocol_InboundMessage.OneOf_Message, rhs: Sass_EmbeddedProtocol_InboundMessage.OneOf_Message) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.compileRequest, .compileRequest): return {
        guard case .compileRequest(let l) = lhs, case .compileRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.canonicalizeResponse, .canonicalizeResponse): return {
        guard case .canonicalizeResponse(let l) = lhs, case .canonicalizeResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.importResponse, .importResponse): return {
        guard case .importResponse(let l) = lhs, case .importResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.fileImportResponse, .fileImportResponse): return {
        guard case .fileImportResponse(let l) = lhs, case .fileImportResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.functionCallResponse, .functionCallResponse): return {
        guard case .functionCallResponse(let l) = lhs, case .functionCallResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.versionRequest, .versionRequest): return {
        guard case .versionRequest(let l) = lhs, case .versionRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Possible syntaxes for a Sass stylesheet.
  enum Syntax: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// The CSS-superset `.scss` syntax.
    case scss // = 0

    /// The indented `.sass` syntax.
    case indented // = 1

    /// Plain CSS syntax that doesn't support any special Sass features.
    case css // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .scss
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .scss
      case 1: self = .indented
      case 2: self = .css
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .scss: return 0
      case .indented: return 1
      case .css: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// A request for information about the version of the embedded compiler. The
  /// host can use this to provide diagnostic information to the user, to check
  /// which features the compiler supports, or to ensure that it's compatible
  /// with the same protocol version the compiler supports.
  struct VersionRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// This version request's id. Mandatory.
    var id: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// A request that compiles an entrypoint to CSS.
  struct CompileRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// This compilation's request id. This is included in messages sent from the
    /// compiler to the host. Mandatory.
    var id: UInt32 = 0

    /// The input stylesheet to parse. Mandatory.
    var input: Sass_EmbeddedProtocol_InboundMessage.CompileRequest.OneOf_Input? = nil

    /// A stylesheet loaded from its contents.
    var string: Sass_EmbeddedProtocol_InboundMessage.CompileRequest.StringInput {
      get {
        if case .string(let v)? = input {return v}
        return Sass_EmbeddedProtocol_InboundMessage.CompileRequest.StringInput()
      }
      set {input = .string(newValue)}
    }

    /// A stylesheet loaded from the given path on the filesystem.
    var path: String {
      get {
        if case .path(let v)? = input {return v}
        return String()
      }
      set {input = .path(newValue)}
    }

    /// How to format the CSS output.
    var style: Sass_EmbeddedProtocol_InboundMessage.CompileRequest.OutputStyle = .expanded

    /// Whether to generate a source map. Note that this will *not* add a source
    /// map comment to the stylesheet; that's up to the host or its users.
    var sourceMap: Bool = false

    /// Importers (including load paths on the filesystem) to use when resolving
    /// imports that can't be resolved relative to the file that contains it. Each
    /// importer is checked in order until one recognizes the imported URL.
    var importers: [Sass_EmbeddedProtocol_InboundMessage.CompileRequest.Importer] = []

    /// Signatures for custom global functions whose behavior is defined by the
    /// host. These must be valid Sass function signatures that could appear in
    /// after `@function` in a Sass stylesheet, such as
    /// `mix($color1, $color2, $weight: 50%)`.
    ///
    /// Compilers must ensure that pure-Sass functions take precedence over
    /// custom global functions. They must also reject any custom function names
    /// that conflict with function names built into the Sass language.
    var globalFunctions: [String] = []

    /// Whether to use terminal colors in the formatted message of errors and
    /// logs.
    var alertColor: Bool = false

    /// Whether to encode the formatted message of errors and logs in ASCII.
    var alertAscii: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The input stylesheet to parse. Mandatory.
    enum OneOf_Input: Equatable {
      /// A stylesheet loaded from its contents.
      case string(Sass_EmbeddedProtocol_InboundMessage.CompileRequest.StringInput)
      /// A stylesheet loaded from the given path on the filesystem.
      case path(String)

    #if !swift(>=4.1)
      static func ==(lhs: Sass_EmbeddedProtocol_InboundMessage.CompileRequest.OneOf_Input, rhs: Sass_EmbeddedProtocol_InboundMessage.CompileRequest.OneOf_Input) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.string, .string): return {
          guard case .string(let l) = lhs, case .string(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.path, .path): return {
          guard case .path(let l) = lhs, case .path(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    /// Possible ways to format the CSS output. The compiler is not required to
    /// support all possible options; if the host requests an unsupported style,
    /// the compiler should choose the closest supported style.
    enum OutputStyle: SwiftProtobuf.Enum {
      typealias RawValue = Int

      /// Each selector and declaration is written on its own line.
      case expanded // = 0

      /// The entire stylesheet is written on a single line, with as few
      /// characters as possible.
      case compressed // = 1
      case UNRECOGNIZED(Int)

      init() {
        self = .expanded
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .expanded
        case 1: self = .compressed
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .expanded: return 0
        case .compressed: return 1
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    /// An input stylesheet provided as plain text, rather than loaded from the
    /// filesystem.
    struct StringInput {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The contents of the stylesheet.
      var source: String = String()

      /// The location from which `source` was loaded. If this is empty, it
      /// indicates that the URL is unknown.
      ///
      /// This must be a URL recognized by `importer`, if it's passed.
      var url: String = String()

      /// The syntax to use to parse `source`.
      var syntax: Sass_EmbeddedProtocol_InboundMessage.Syntax = .scss

      /// The importer to use to resolve imports relative to `url`.
      var importer: Sass_EmbeddedProtocol_InboundMessage.CompileRequest.Importer {
        get {return _importer ?? Sass_EmbeddedProtocol_InboundMessage.CompileRequest.Importer()}
        set {_importer = newValue}
      }
      /// Returns true if `importer` has been explicitly set.
      var hasImporter: Bool {return self._importer != nil}
      /// Clears the value of `importer`. Subsequent reads from it will return its default value.
      mutating func clearImporter() {self._importer = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _importer: Sass_EmbeddedProtocol_InboundMessage.CompileRequest.Importer? = nil
    }

    /// A wrapper message that represents either a user-defined importer or a
    /// load path on disk. This must be a wrapper because `oneof` types can't be
    /// `repeated`.
    struct Importer {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The possible types of importer. Mandatory.
      var importer: Sass_EmbeddedProtocol_InboundMessage.CompileRequest.Importer.OneOf_Importer? = nil

      /// A built-in importer that loads Sass files within the given directory
      /// on disk.
      var path: String {
        get {
          if case .path(let v)? = importer {return v}
          return String()
        }
        set {importer = .path(newValue)}
      }

      /// A unique ID for a user-defined importer. This ID will be included in
      /// outbound `CanonicalizeRequest` and `ImportRequest` messages to
      /// indicate which importer is being called. The host is responsible for
      /// generating this ID and ensuring that it's unique across all
      /// importers registered for this compilation.
      var importerID: UInt32 {
        get {
          if case .importerID(let v)? = importer {return v}
          return 0
        }
        set {importer = .importerID(newValue)}
      }

      /// A unique ID for a special kind of user-defined importer that tells
      /// the compiler where to look for files on the physical filesystem, but
      /// leaves the details of resolving partials and extensions and loading
      /// the file from disk up to the compiler itself.
      ///
      /// This ID will be included in outbound `FileImportRequest` messages to
      /// indicate which importer is being called. The host is responsible for
      /// generating this ID and ensuring that it's unique across all importers
      /// registered for this compilation.
      var fileImporterID: UInt32 {
        get {
          if case .fileImporterID(let v)? = importer {return v}
          return 0
        }
        set {importer = .fileImporterID(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      /// The possible types of importer. Mandatory.
      enum OneOf_Importer: Equatable {
        /// A built-in importer that loads Sass files within the given directory
        /// on disk.
        case path(String)
        /// A unique ID for a user-defined importer. This ID will be included in
        /// outbound `CanonicalizeRequest` and `ImportRequest` messages to
        /// indicate which importer is being called. The host is responsible for
        /// generating this ID and ensuring that it's unique across all
        /// importers registered for this compilation.
        case importerID(UInt32)
        /// A unique ID for a special kind of user-defined importer that tells
        /// the compiler where to look for files on the physical filesystem, but
        /// leaves the details of resolving partials and extensions and loading
        /// the file from disk up to the compiler itself.
        ///
        /// This ID will be included in outbound `FileImportRequest` messages to
        /// indicate which importer is being called. The host is responsible for
        /// generating this ID and ensuring that it's unique across all importers
        /// registered for this compilation.
        case fileImporterID(UInt32)

      #if !swift(>=4.1)
        static func ==(lhs: Sass_EmbeddedProtocol_InboundMessage.CompileRequest.Importer.OneOf_Importer, rhs: Sass_EmbeddedProtocol_InboundMessage.CompileRequest.Importer.OneOf_Importer) -> Bool {
          // The use of inline closures is to circumvent an issue where the compiler
          // allocates stack space for every case branch when no optimizations are
          // enabled. https://github.com/apple/swift-protobuf/issues/1034
          switch (lhs, rhs) {
          case (.path, .path): return {
            guard case .path(let l) = lhs, case .path(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.importerID, .importerID): return {
            guard case .importerID(let l) = lhs, case .importerID(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.fileImporterID, .fileImporterID): return {
            guard case .fileImporterID(let l) = lhs, case .fileImporterID(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          default: return false
          }
        }
      #endif
      }

      init() {}
    }

    init() {}
  }

  /// A response indicating the result of canonicalizing an imported URL.
  struct CanonicalizeResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: UInt32 = 0

    /// The result of canonicalization. Optional. If this is `null`, it indicates
    /// that the importer either did not recognize the URL, or could not find a
    /// stylesheet at the location it referred to.
    var result: Sass_EmbeddedProtocol_InboundMessage.CanonicalizeResponse.OneOf_Result? = nil

    /// The successfully canonicalized URL. This must be an absolute URL,
    /// including scheme.
    var url: String {
      get {
        if case .url(let v)? = result {return v}
        return String()
      }
      set {result = .url(newValue)}
    }

    /// An error message explaining why canonicalization failed.
    ///
    /// This indicates that a stylesheet was found, but a canonical URL for it
    /// could not be determined. If no stylesheet was found, `result` should be
    /// `null` instead.
    var error: String {
      get {
        if case .error(let v)? = result {return v}
        return String()
      }
      set {result = .error(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The result of canonicalization. Optional. If this is `null`, it indicates
    /// that the importer either did not recognize the URL, or could not find a
    /// stylesheet at the location it referred to.
    enum OneOf_Result: Equatable {
      /// The successfully canonicalized URL. This must be an absolute URL,
      /// including scheme.
      case url(String)
      /// An error message explaining why canonicalization failed.
      ///
      /// This indicates that a stylesheet was found, but a canonical URL for it
      /// could not be determined. If no stylesheet was found, `result` should be
      /// `null` instead.
      case error(String)

    #if !swift(>=4.1)
      static func ==(lhs: Sass_EmbeddedProtocol_InboundMessage.CanonicalizeResponse.OneOf_Result, rhs: Sass_EmbeddedProtocol_InboundMessage.CanonicalizeResponse.OneOf_Result) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.url, .url): return {
          guard case .url(let l) = lhs, case .url(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.error, .error): return {
          guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    init() {}
  }

  /// A response indicating the result of importing a canonical URL.
  struct ImportResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: UInt32 = 0

    /// The result of loading the URL. Mandatory.
    var result: Sass_EmbeddedProtocol_InboundMessage.ImportResponse.OneOf_Result? = nil

    /// The contents of the loaded stylesheet.
    var success: Sass_EmbeddedProtocol_InboundMessage.ImportResponse.ImportSuccess {
      get {
        if case .success(let v)? = result {return v}
        return Sass_EmbeddedProtocol_InboundMessage.ImportResponse.ImportSuccess()
      }
      set {result = .success(newValue)}
    }

    /// An error message explaining why the URL could not be loaded.
    var error: String {
      get {
        if case .error(let v)? = result {return v}
        return String()
      }
      set {result = .error(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The result of loading the URL. Mandatory.
    enum OneOf_Result: Equatable {
      /// The contents of the loaded stylesheet.
      case success(Sass_EmbeddedProtocol_InboundMessage.ImportResponse.ImportSuccess)
      /// An error message explaining why the URL could not be loaded.
      case error(String)

    #if !swift(>=4.1)
      static func ==(lhs: Sass_EmbeddedProtocol_InboundMessage.ImportResponse.OneOf_Result, rhs: Sass_EmbeddedProtocol_InboundMessage.ImportResponse.OneOf_Result) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.success, .success): return {
          guard case .success(let l) = lhs, case .success(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.error, .error): return {
          guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    /// The stylesheet's contents were loaded successfully.
    struct ImportSuccess {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The text of the stylesheet. Mandatory.
      var contents: String = String()

      /// The syntax of `contents`. Mandatory.
      var syntax: Sass_EmbeddedProtocol_InboundMessage.Syntax = .scss

      /// An absolute, browser-accessible URL indicating the resolved location of
      /// the imported stylesheet. Optional.
      ///
      /// This should be a `file:` URL if one is available, but an `http:` URL is
      /// acceptable as well. If no URL is supplied, a `data:` URL is generated
      /// automatically from `contents`.
      ///
      /// If this is provided, it must be an absolute URL, including scheme.
      var sourceMapURL: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  /// A response indicating the result of redirecting a URL to the filesystem.
  struct FileImportResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: UInt32 = 0

    /// The result of loading the URL. Mandatory.
    var result: Sass_EmbeddedProtocol_InboundMessage.FileImportResponse.OneOf_Result? = nil

    /// The absolute `file:` URL to look for the file on the physical
    /// filesystem.
    ///
    /// The host must ensure that this URL follows the format for an absolute
    /// `file:` URL on the current operating system without a hostname, and the
    /// compiler must verify this to the best of its ability. See
    /// https://en.wikipedia.org/wiki/File_URI_scheme for details on the
    /// format.
    ///
    /// The compiler must handle turning this into a canonical URL by resolving
    /// it for partials, file extensions, and index files. The compiler must
    /// then loading the contents of the resulting canonical URL from the
    /// filesystem.
    var fileURL: String {
      get {
        if case .fileURL(let v)? = result {return v}
        return String()
      }
      set {result = .fileURL(newValue)}
    }

    /// An error message explaining why the URL could not be loaded.
    var error: String {
      get {
        if case .error(let v)? = result {return v}
        return String()
      }
      set {result = .error(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The result of loading the URL. Mandatory.
    enum OneOf_Result: Equatable {
      /// The absolute `file:` URL to look for the file on the physical
      /// filesystem.
      ///
      /// The host must ensure that this URL follows the format for an absolute
      /// `file:` URL on the current operating system without a hostname, and the
      /// compiler must verify this to the best of its ability. See
      /// https://en.wikipedia.org/wiki/File_URI_scheme for details on the
      /// format.
      ///
      /// The compiler must handle turning this into a canonical URL by resolving
      /// it for partials, file extensions, and index files. The compiler must
      /// then loading the contents of the resulting canonical URL from the
      /// filesystem.
      case fileURL(String)
      /// An error message explaining why the URL could not be loaded.
      case error(String)

    #if !swift(>=4.1)
      static func ==(lhs: Sass_EmbeddedProtocol_InboundMessage.FileImportResponse.OneOf_Result, rhs: Sass_EmbeddedProtocol_InboundMessage.FileImportResponse.OneOf_Result) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.fileURL, .fileURL): return {
          guard case .fileURL(let l) = lhs, case .fileURL(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.error, .error): return {
          guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    init() {}
  }

  /// A response indicating the result of calling a custom Sass function defined
  /// in the host.
  struct FunctionCallResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: UInt32 = 0

    /// The result of calling the function. Mandatory.
    var result: Sass_EmbeddedProtocol_InboundMessage.FunctionCallResponse.OneOf_Result? = nil

    /// The return value of a successful function call.
    var success: Sass_EmbeddedProtocol_Value {
      get {
        if case .success(let v)? = result {return v}
        return Sass_EmbeddedProtocol_Value()
      }
      set {result = .success(newValue)}
    }

    /// An error message explaining why the function call failed.
    var error: String {
      get {
        if case .error(let v)? = result {return v}
        return String()
      }
      set {result = .error(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The result of calling the function. Mandatory.
    enum OneOf_Result: Equatable {
      /// The return value of a successful function call.
      case success(Sass_EmbeddedProtocol_Value)
      /// An error message explaining why the function call failed.
      case error(String)

    #if !swift(>=4.1)
      static func ==(lhs: Sass_EmbeddedProtocol_InboundMessage.FunctionCallResponse.OneOf_Result, rhs: Sass_EmbeddedProtocol_InboundMessage.FunctionCallResponse.OneOf_Result) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.success, .success): return {
          guard case .success(let l) = lhs, case .success(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.error, .error): return {
          guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    init() {}
  }

  init() {}
}

#if swift(>=4.2)

extension Sass_EmbeddedProtocol_InboundMessage.Syntax: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sass_EmbeddedProtocol_InboundMessage.Syntax] = [
    .scss,
    .indented,
    .css,
  ]
}

extension Sass_EmbeddedProtocol_InboundMessage.CompileRequest.OutputStyle: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sass_EmbeddedProtocol_InboundMessage.CompileRequest.OutputStyle] = [
    .expanded,
    .compressed,
  ]
}

#endif  // swift(>=4.2)

/// The wrapper type for all messages sent from the compiler to the host. This
/// provides a `oneof` that makes it possible to determine the type of each
/// outbound message.
struct Sass_EmbeddedProtocol_OutboundMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The wrapped message. Mandatory.
  var message: Sass_EmbeddedProtocol_OutboundMessage.OneOf_Message? = nil

  var error: Sass_EmbeddedProtocol_ProtocolError {
    get {
      if case .error(let v)? = message {return v}
      return Sass_EmbeddedProtocol_ProtocolError()
    }
    set {message = .error(newValue)}
  }

  var compileResponse: Sass_EmbeddedProtocol_OutboundMessage.CompileResponse {
    get {
      if case .compileResponse(let v)? = message {return v}
      return Sass_EmbeddedProtocol_OutboundMessage.CompileResponse()
    }
    set {message = .compileResponse(newValue)}
  }

  var logEvent: Sass_EmbeddedProtocol_OutboundMessage.LogEvent {
    get {
      if case .logEvent(let v)? = message {return v}
      return Sass_EmbeddedProtocol_OutboundMessage.LogEvent()
    }
    set {message = .logEvent(newValue)}
  }

  var canonicalizeRequest: Sass_EmbeddedProtocol_OutboundMessage.CanonicalizeRequest {
    get {
      if case .canonicalizeRequest(let v)? = message {return v}
      return Sass_EmbeddedProtocol_OutboundMessage.CanonicalizeRequest()
    }
    set {message = .canonicalizeRequest(newValue)}
  }

  var importRequest: Sass_EmbeddedProtocol_OutboundMessage.ImportRequest {
    get {
      if case .importRequest(let v)? = message {return v}
      return Sass_EmbeddedProtocol_OutboundMessage.ImportRequest()
    }
    set {message = .importRequest(newValue)}
  }

  var fileImportRequest: Sass_EmbeddedProtocol_OutboundMessage.FileImportRequest {
    get {
      if case .fileImportRequest(let v)? = message {return v}
      return Sass_EmbeddedProtocol_OutboundMessage.FileImportRequest()
    }
    set {message = .fileImportRequest(newValue)}
  }

  var functionCallRequest: Sass_EmbeddedProtocol_OutboundMessage.FunctionCallRequest {
    get {
      if case .functionCallRequest(let v)? = message {return v}
      return Sass_EmbeddedProtocol_OutboundMessage.FunctionCallRequest()
    }
    set {message = .functionCallRequest(newValue)}
  }

  var versionResponse: Sass_EmbeddedProtocol_OutboundMessage.VersionResponse {
    get {
      if case .versionResponse(let v)? = message {return v}
      return Sass_EmbeddedProtocol_OutboundMessage.VersionResponse()
    }
    set {message = .versionResponse(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The wrapped message. Mandatory.
  enum OneOf_Message: Equatable {
    case error(Sass_EmbeddedProtocol_ProtocolError)
    case compileResponse(Sass_EmbeddedProtocol_OutboundMessage.CompileResponse)
    case logEvent(Sass_EmbeddedProtocol_OutboundMessage.LogEvent)
    case canonicalizeRequest(Sass_EmbeddedProtocol_OutboundMessage.CanonicalizeRequest)
    case importRequest(Sass_EmbeddedProtocol_OutboundMessage.ImportRequest)
    case fileImportRequest(Sass_EmbeddedProtocol_OutboundMessage.FileImportRequest)
    case functionCallRequest(Sass_EmbeddedProtocol_OutboundMessage.FunctionCallRequest)
    case versionResponse(Sass_EmbeddedProtocol_OutboundMessage.VersionResponse)

  #if !swift(>=4.1)
    static func ==(lhs: Sass_EmbeddedProtocol_OutboundMessage.OneOf_Message, rhs: Sass_EmbeddedProtocol_OutboundMessage.OneOf_Message) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.compileResponse, .compileResponse): return {
        guard case .compileResponse(let l) = lhs, case .compileResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.logEvent, .logEvent): return {
        guard case .logEvent(let l) = lhs, case .logEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.canonicalizeRequest, .canonicalizeRequest): return {
        guard case .canonicalizeRequest(let l) = lhs, case .canonicalizeRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.importRequest, .importRequest): return {
        guard case .importRequest(let l) = lhs, case .importRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.fileImportRequest, .fileImportRequest): return {
        guard case .fileImportRequest(let l) = lhs, case .fileImportRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.functionCallRequest, .functionCallRequest): return {
        guard case .functionCallRequest(let l) = lhs, case .functionCallRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.versionResponse, .versionResponse): return {
        guard case .versionResponse(let l) = lhs, case .versionResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// A response that contains the version of the embedded compiler.
  struct VersionResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// This version request's id. Mandatory.
    var id: UInt32 = 0

    /// The version of the embedded protocol, in semver format.
    var protocolVersion: String = String()

    /// The version of the embedded compiler package. This has no guaranteed
    /// format, although compilers are encouraged to use semver.
    var compilerVersion: String = String()

    /// The version of the Sass implementation that the embedded compiler wraps.
    /// This has no guaranteed format, although Sass implementations are
    /// encouraged to use semver.
    var implementationVersion: String = String()

    /// The name of the Sass implementation that the embedded compiler wraps.
    var implementationName: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// A response that contains the result of a compilation.
  struct CompileResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The compilation's request id. Mandatory.
    var id: UInt32 = 0

    /// The success or failure result of the compilation. Mandatory.
    var result: Sass_EmbeddedProtocol_OutboundMessage.CompileResponse.OneOf_Result? = nil

    /// The result of a successful compilation.
    var success: Sass_EmbeddedProtocol_OutboundMessage.CompileResponse.CompileSuccess {
      get {
        if case .success(let v)? = result {return v}
        return Sass_EmbeddedProtocol_OutboundMessage.CompileResponse.CompileSuccess()
      }
      set {result = .success(newValue)}
    }

    /// The result of a failed compilation.
    var failure: Sass_EmbeddedProtocol_OutboundMessage.CompileResponse.CompileFailure {
      get {
        if case .failure(let v)? = result {return v}
        return Sass_EmbeddedProtocol_OutboundMessage.CompileResponse.CompileFailure()
      }
      set {result = .failure(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The success or failure result of the compilation. Mandatory.
    enum OneOf_Result: Equatable {
      /// The result of a successful compilation.
      case success(Sass_EmbeddedProtocol_OutboundMessage.CompileResponse.CompileSuccess)
      /// The result of a failed compilation.
      case failure(Sass_EmbeddedProtocol_OutboundMessage.CompileResponse.CompileFailure)

    #if !swift(>=4.1)
      static func ==(lhs: Sass_EmbeddedProtocol_OutboundMessage.CompileResponse.OneOf_Result, rhs: Sass_EmbeddedProtocol_OutboundMessage.CompileResponse.OneOf_Result) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.success, .success): return {
          guard case .success(let l) = lhs, case .success(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.failure, .failure): return {
          guard case .failure(let l) = lhs, case .failure(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    /// A message indicating that the Sass file was successfully compiled to CSS.
    struct CompileSuccess {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The compiled CSS.
      var css: String = String()

      /// The JSON-encoded source map, or the empty string if
      /// `CompileRequest.source_map` was `false`.
      ///
      /// The compiler must not add a `"file"` key to this source map. It's the
      /// host's (or the host's user's) responsibility to determine how the
      /// generated CSS can be reached from the source map.
      var sourceMap: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    /// A message indicating that the Sass file could not be successfully
    /// compiled to CSS.
    struct CompileFailure {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// A message describing the reason for the failure.
      var message: String = String()

      /// The span associated with the failure. Optional.
      var span: Sass_EmbeddedProtocol_SourceSpan {
        get {return _span ?? Sass_EmbeddedProtocol_SourceSpan()}
        set {_span = newValue}
      }
      /// Returns true if `span` has been explicitly set.
      var hasSpan: Bool {return self._span != nil}
      /// Clears the value of `span`. Subsequent reads from it will return its default value.
      mutating func clearSpan() {self._span = nil}

      /// The stack trace associated with the failure.
      ///
      /// The empty string indicates that no stack trace is available. Otherwise,
      /// the format of this stack trace is not specified and is likely to be
      /// inconsistent between implementations.
      var stackTrace: String = String()

      /// A formatted, human-readable string that contains the message, span
      /// (if available), and trace (if available). The format of this string is
      /// not specified and is likely to be inconsistent between implementations.
      var formatted: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _span: Sass_EmbeddedProtocol_SourceSpan? = nil
    }

    init() {}
  }

  /// An event indicating that a message should be displayed to the user.
  struct LogEvent {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The request id for the compilation that triggered the message. Mandatory.
    var compilationID: UInt32 = 0

    var type: Sass_EmbeddedProtocol_OutboundMessage.LogEvent.TypeEnum = .warning

    /// The text of the message.
    var message: String = String()

    /// The span associated with this message. Optional.
    var span: Sass_EmbeddedProtocol_SourceSpan {
      get {return _span ?? Sass_EmbeddedProtocol_SourceSpan()}
      set {_span = newValue}
    }
    /// Returns true if `span` has been explicitly set.
    var hasSpan: Bool {return self._span != nil}
    /// Clears the value of `span`. Subsequent reads from it will return its default value.
    mutating func clearSpan() {self._span = nil}

    /// The stack trace associated with this message.
    ///
    /// The empty string indicates that no stack trace is available. Otherwise,
    /// the format of this stack trace is not specified and is likely to be
    /// inconsistent between implementations.
    var stackTrace: String = String()

    /// A formatted, human-readable string that contains the message, span (if
    /// available), and trace (if available). The format of this string is not
    /// specified and is likely to be inconsistent between implementations.
    var formatted: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The type of message.
    enum TypeEnum: SwiftProtobuf.Enum {
      typealias RawValue = Int

      /// A warning for something other than a deprecated Sass feature. Often
      /// emitted due to a stylesheet using the `@warn` rule.
      case warning // = 0

      /// A warning indicating that the stylesheet is using a deprecated Sass
      /// feature. Compilers should not add text like "deprecation warning" to
      /// deprecation warnings; it's up to the host to determine how to signal
      /// that to the user.
      case deprecationWarning // = 1

      /// A message generated by the user for their own debugging purposes.
      case debug // = 2
      case UNRECOGNIZED(Int)

      init() {
        self = .warning
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .warning
        case 1: self = .deprecationWarning
        case 2: self = .debug
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .warning: return 0
        case .deprecationWarning: return 1
        case .debug: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    init() {}

    fileprivate var _span: Sass_EmbeddedProtocol_SourceSpan? = nil
  }

  /// A request for a custom importer to convert an imported URL to its canonical
  /// format.
  ///
  /// If the URL is not recognized by this importer, or if no stylesheet is found
  /// at that URL, `CanonicalizeResponse.result` must be `null`.
  ///
  /// Canonical URLs must be absolute, including a scheme. If the import is
  /// referring to a Sass file on disk, the importer is encouraged to respond
  /// with a `CanonicalizeResponse.result.file`, in which case the host will
  /// handle the logic of resolving partials, file extensions, and index files.
  ///
  /// If Sass has already loaded a stylesheet with the returned canonical URL, it
  /// re-uses the existing parse tree. This means that importers must ensure that
  /// the same canonical URL always refers to the same stylesheet, *even across
  /// different importers*. Importers must also ensure that any canonicalized
  /// URLs they return can be passed back to `CanonicalizeRequest` and will be
  /// returned unchanged.
  ///
  /// If this importer's URL format supports file extensions, it should
  /// canonicalize them the same way as the default filesystem importer:
  ///
  /// * The importer should look for stylesheets by adding the prefix `_` to the
  ///   URL's basename, and by adding the extensions `.sass` and `.scss` if the
  ///   URL doesn't already have one of those extensions. For example, if the URL
  ///   was `foo/bar/baz`, the importer would look for:
  ///
  ///   * `foo/bar/baz.sass`
  ///   * `foo/bar/baz.scss`
  ///   * `foo/bar/_baz.sass`
  ///   * `foo/bar/_baz.scss`
  ///
  ///   If the URL was foo/bar/baz.scss, the importer would just look for:
  ///
  ///   * `foo/bar/baz.scss`
  ///   * `foo/bar/_baz.scss`
  ///
  ///   If the importer finds a stylesheet at more than one of these URLs, it
  ///   should respond with a `CanonicalizeResponse.result.error` indicating that
  ///   the import is ambiguous. Note that if the extension is explicitly
  ///   specified, a stylesheet with another extension may exist without error.
  ///
  /// * If none of the possible paths is valid, the importer should perform the
  ///   same resolution on the URL followed by `/index`. In the example above, it
  ///   would look for:
  ///
  ///   * `foo/bar/baz/_index.sass`
  ///   * `foo/bar/baz/index.sass`
  ///   * `foo/bar/baz/_index.scss`
  ///   * `foo/bar/baz/index.scss`
  ///
  ///   As above, if the importer finds a stylesheet at more than one of these
  ///   URLs, it should respond with a `CanonicalizeResponse.result.error`
  ///   indicating that the import is ambiguous.
  struct CanonicalizeRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: UInt32 = 0

    /// The request id for the compilation that triggered the message. Mandatory.
    var compilationID: UInt32 = 0

    /// The unique ID of the importer being invoked. This must match an importer
    /// ID passed to this compilation in `CompileRequest.importers` or
    /// `CompileRequest.input.string.importer`. Mandatory.
    var importerID: UInt32 = 0

    /// The URL of the import to be canonicalized. This may be either absolute or
    /// relative.
    ///
    /// When loading a URL, the compiler must first try resolving that URL
    /// relative to the canonical URL of the current file, and canonicalizing the
    /// result using the importer that loaded the current file. If this returns
    /// `null`, the compiler must then try canonicalizing the original URL with
    /// each importer in order until one returns something other than `null`.
    /// That is the result of the import.
    var url: String = String()

    //// Whether this request comes from an `@import` rule.
    ////
    //// When evaluating `@import` rules, URLs should canonicalize to an
    //// [import-only file] if one exists for the URL being canonicalized.
    //// Otherwise, canonicalization should be identical for `@import` and `@use`
    //// rules.
    ////
    //// [import-only file]: https://sass-lang.com/documentation/at-rules/import#import-only-files
    var fromImport: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// A request for a custom importer to load the contents of a stylesheet.
  struct ImportRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: UInt32 = 0

    /// The request id for the compilation that triggered the message. Mandatory.
    var compilationID: UInt32 = 0

    /// The unique ID of the importer being invoked. This must match an
    /// `Importer.importer_id` passed to this compilation in
    /// `CompileRequest.importers` or `CompileRequest.input.string.importer`.
    /// Mandatory.
    var importerID: UInt32 = 0

    /// The canonical URL of the import. This is guaranteed to be a URL returned
    /// by a `CanonicalizeRequest` to this importer.
    var url: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// A request for a custom filesystem importer to load the contents of a
  /// stylesheet.
  struct FileImportRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: UInt32 = 0

    /// The request id for the compilation that triggered the message. Mandatory.
    var compilationID: UInt32 = 0

    /// The unique ID of the importer being invoked. This must match an
    /// `Importer.file_importer_id` passed to this compilation in
    /// `CompileRequest.importers` or `CompileRequest.input.string.importer`.
    /// Mandatory.
    var importerID: UInt32 = 0

    /// The (non-canonicalized) URL of the import.
    var url: String = String()

    //// Whether this request comes from an `@import` rule.
    ////
    //// When evaluating `@import` rules, filesystem importers should load an
    //// [import-only file] if one exists for the URL being canonicalized.
    //// Otherwise, canonicalization should be identical for `@import` and `@use`
    //// rules.
    ////
    //// [import-only file]: https://sass-lang.com/documentation/at-rules/import#import-only-files
    var fromImport: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// A request to invoke a custom Sass function and return its result.
  struct FunctionCallRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: UInt32 = 0

    /// The request id for the compilation that triggered the message. Mandatory.
    var compilationID: UInt32 = 0

    /// An identifier that indicates which function to invoke. Mandatory.
    var identifier: Sass_EmbeddedProtocol_OutboundMessage.FunctionCallRequest.OneOf_Identifier? = nil

    /// The name of the function to invoke.
    ///
    /// This must match the name of a function signature the host passed to the
    /// corresponding `CompileRequest.global_functions` call, including hyphens
    /// and underscores.
    var name: String {
      get {
        if case .name(let v)? = identifier {return v}
        return String()
      }
      set {identifier = .name(newValue)}
    }

    /// The opaque ID of the function to invoke.
    ///
    /// This must match the ID of a `Value.HostFunction` that the host passed
    /// to the compiler.
    var functionID: UInt32 {
      get {
        if case .functionID(let v)? = identifier {return v}
        return 0
      }
      set {identifier = .functionID(newValue)}
    }

    /// The arguments passed to the function, in the order they appear in the
    /// function signature passed to `CompileRequest.global_functions`. Mandatory.
    ///
    /// The compiler must ensure that a valid number of arguments are passed for
    /// the given signature, that default argument values are instantiated
    /// appropriately, and that variable argument lists (`$args...`) are passed
    /// as `Value.ArgumentList`s.
    var arguments: [Sass_EmbeddedProtocol_Value] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// An identifier that indicates which function to invoke. Mandatory.
    enum OneOf_Identifier: Equatable {
      /// The name of the function to invoke.
      ///
      /// This must match the name of a function signature the host passed to the
      /// corresponding `CompileRequest.global_functions` call, including hyphens
      /// and underscores.
      case name(String)
      /// The opaque ID of the function to invoke.
      ///
      /// This must match the ID of a `Value.HostFunction` that the host passed
      /// to the compiler.
      case functionID(UInt32)

    #if !swift(>=4.1)
      static func ==(lhs: Sass_EmbeddedProtocol_OutboundMessage.FunctionCallRequest.OneOf_Identifier, rhs: Sass_EmbeddedProtocol_OutboundMessage.FunctionCallRequest.OneOf_Identifier) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.name, .name): return {
          guard case .name(let l) = lhs, case .name(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.functionID, .functionID): return {
          guard case .functionID(let l) = lhs, case .functionID(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    init() {}
  }

  init() {}
}

#if swift(>=4.2)

extension Sass_EmbeddedProtocol_OutboundMessage.LogEvent.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sass_EmbeddedProtocol_OutboundMessage.LogEvent.TypeEnum] = [
    .warning,
    .deprecationWarning,
    .debug,
  ]
}

#endif  // swift(>=4.2)

/// An error reported when an endpoint violates the embedded Sass protocol.
struct Sass_EmbeddedProtocol_ProtocolError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Sass_EmbeddedProtocol_ProtocolError.ErrorType = .parse

  /// The ID of the request that had an error. This MUST be `4294967295` if the
  /// request ID couldn't be determined, or if the error is being reported for a
  /// response or an event.
  var id: UInt32 = 0

  /// A human-readable message providing more detail about the error.
  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Potential types of errors.
  enum ErrorType: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// A message was received that couldn't be decoded as an `InboundMessage`
    /// (for the compiler) or `OutboundMessage` (for the host).
    case parse // = 0

    /// A message was received that violated a documented restriction, such as
    /// not providing a mandatory field.
    case params // = 1

    /// Something unexpected went wrong within the endpoint.
    case `internal` // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .parse
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .parse
      case 1: self = .params
      case 2: self = .internal
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .parse: return 0
      case .params: return 1
      case .internal: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Sass_EmbeddedProtocol_ProtocolError.ErrorType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sass_EmbeddedProtocol_ProtocolError.ErrorType] = [
    .parse,
    .params,
    .internal,
  ]
}

#endif  // swift(>=4.2)

/// A chunk of a source file.
struct Sass_EmbeddedProtocol_SourceSpan {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The text covered by the source span. Compilers must guarantee that this is
  /// the text between `start.offset` and `end.offset` in the source file
  /// referred to by `url`.
  var text: String = String()

  /// The location of the first character in this span. Mandatory.
  var start: Sass_EmbeddedProtocol_SourceSpan.SourceLocation {
    get {return _start ?? Sass_EmbeddedProtocol_SourceSpan.SourceLocation()}
    set {_start = newValue}
  }
  /// Returns true if `start` has been explicitly set.
  var hasStart: Bool {return self._start != nil}
  /// Clears the value of `start`. Subsequent reads from it will return its default value.
  mutating func clearStart() {self._start = nil}

  /// The location of the first character after this span. Optional.
  ///
  /// If this is omitted, it indicates that the span is empty and points
  /// immediately before `start`. In that case, `text` must be empty.
  ///
  /// This must not point to a location before `start`.
  var end: Sass_EmbeddedProtocol_SourceSpan.SourceLocation {
    get {return _end ?? Sass_EmbeddedProtocol_SourceSpan.SourceLocation()}
    set {_end = newValue}
  }
  /// Returns true if `end` has been explicitly set.
  var hasEnd: Bool {return self._end != nil}
  /// Clears the value of `end`. Subsequent reads from it will return its default value.
  mutating func clearEnd() {self._end = nil}

  /// The URL of the file to which this span refers.
  ///
  /// This may be empty, indicating that the span refers to a
  /// `CompileRequest.StringInput` file that doesn't specify a URL.
  var url: String = String()

  /// Additional source text surrounding this span.
  ///
  /// If this isn't empty, it must contain `text`. Furthermore, `text` must begin
  /// at column `start.column` of a line in `context`.
  ///
  /// This usually contains the full lines the span begins and ends on if the
  /// span itself doesn't cover the full lines.
  var context: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A single point in a source file.
  struct SourceLocation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The 0-based offset of this location within the source file. Mandatory.
    var offset: UInt32 = 0

    /// The 0-based line number of this location within the source file.
    /// Mandatory.
    var line: UInt32 = 0

    /// The 0-based column number of this location within its line. Mandatory.
    var column: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _start: Sass_EmbeddedProtocol_SourceSpan.SourceLocation? = nil
  fileprivate var _end: Sass_EmbeddedProtocol_SourceSpan.SourceLocation? = nil
}

/// A SassScript value, passed to and returned by functions.
struct Sass_EmbeddedProtocol_Value {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The value itself. Mandatory.
  ///
  /// This is wrapped in a message type rather than used directly to reduce
  /// repetition, and because oneofs can't be repeated.
  var value: Sass_EmbeddedProtocol_Value.OneOf_Value? = nil

  var string: Sass_EmbeddedProtocol_Value.StringMessage {
    get {
      if case .string(let v)? = value {return v}
      return Sass_EmbeddedProtocol_Value.StringMessage()
    }
    set {value = .string(newValue)}
  }

  var number: Sass_EmbeddedProtocol_Value.Number {
    get {
      if case .number(let v)? = value {return v}
      return Sass_EmbeddedProtocol_Value.Number()
    }
    set {value = .number(newValue)}
  }

  var rgbColor: Sass_EmbeddedProtocol_Value.RgbColor {
    get {
      if case .rgbColor(let v)? = value {return v}
      return Sass_EmbeddedProtocol_Value.RgbColor()
    }
    set {value = .rgbColor(newValue)}
  }

  var hslColor: Sass_EmbeddedProtocol_Value.HslColor {
    get {
      if case .hslColor(let v)? = value {return v}
      return Sass_EmbeddedProtocol_Value.HslColor()
    }
    set {value = .hslColor(newValue)}
  }

  var list: Sass_EmbeddedProtocol_Value.List {
    get {
      if case .list(let v)? = value {return v}
      return Sass_EmbeddedProtocol_Value.List()
    }
    set {value = .list(newValue)}
  }

  var map: Sass_EmbeddedProtocol_Value.Map {
    get {
      if case .map(let v)? = value {return v}
      return Sass_EmbeddedProtocol_Value.Map()
    }
    set {value = .map(newValue)}
  }

  var singleton: Sass_EmbeddedProtocol_Value.Singleton {
    get {
      if case .singleton(let v)? = value {return v}
      return .true
    }
    set {value = .singleton(newValue)}
  }

  var compilerFunction: Sass_EmbeddedProtocol_Value.CompilerFunction {
    get {
      if case .compilerFunction(let v)? = value {return v}
      return Sass_EmbeddedProtocol_Value.CompilerFunction()
    }
    set {value = .compilerFunction(newValue)}
  }

  var hostFunction: Sass_EmbeddedProtocol_Value.HostFunction {
    get {
      if case .hostFunction(let v)? = value {return v}
      return Sass_EmbeddedProtocol_Value.HostFunction()
    }
    set {value = .hostFunction(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The value itself. Mandatory.
  ///
  /// This is wrapped in a message type rather than used directly to reduce
  /// repetition, and because oneofs can't be repeated.
  enum OneOf_Value: Equatable {
    case string(Sass_EmbeddedProtocol_Value.StringMessage)
    case number(Sass_EmbeddedProtocol_Value.Number)
    case rgbColor(Sass_EmbeddedProtocol_Value.RgbColor)
    case hslColor(Sass_EmbeddedProtocol_Value.HslColor)
    case list(Sass_EmbeddedProtocol_Value.List)
    case map(Sass_EmbeddedProtocol_Value.Map)
    case singleton(Sass_EmbeddedProtocol_Value.Singleton)
    case compilerFunction(Sass_EmbeddedProtocol_Value.CompilerFunction)
    case hostFunction(Sass_EmbeddedProtocol_Value.HostFunction)

  #if !swift(>=4.1)
    static func ==(lhs: Sass_EmbeddedProtocol_Value.OneOf_Value, rhs: Sass_EmbeddedProtocol_Value.OneOf_Value) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.string, .string): return {
        guard case .string(let l) = lhs, case .string(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.number, .number): return {
        guard case .number(let l) = lhs, case .number(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.rgbColor, .rgbColor): return {
        guard case .rgbColor(let l) = lhs, case .rgbColor(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hslColor, .hslColor): return {
        guard case .hslColor(let l) = lhs, case .hslColor(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.list, .list): return {
        guard case .list(let l) = lhs, case .list(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.map, .map): return {
        guard case .map(let l) = lhs, case .map(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.singleton, .singleton): return {
        guard case .singleton(let l) = lhs, case .singleton(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.compilerFunction, .compilerFunction): return {
        guard case .compilerFunction(let l) = lhs, case .compilerFunction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hostFunction, .hostFunction): return {
        guard case .hostFunction(let l) = lhs, case .hostFunction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Singleton SassScript values that have no internal state.
  enum Singleton: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// The SassScript boolean true value.
    case `true` // = 0

    /// The SassScript boolean false value.
    case `false` // = 1

    /// The SassScript null value.
    case null // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .true
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .true
      case 1: self = .false
      case 2: self = .null
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .true: return 0
      case .false: return 1
      case .null: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// A SassScript string value.
  struct StringMessage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The contents of the string. Mandatory.
    var text: String = String()

    /// Whether the string is quoted or unquoted. Mandatory.
    var quoted: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// A SassScript number value.
  struct Number {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The number's numeric value. Mandatory.
    var value: Double = 0

    /// The number's numerator units.
    ///
    /// The endpoint sending the number must ensure that no numerator units are
    /// [compatible][] with any denominator units. Such compatible units must be
    /// simplified away according to the multiplicative factor between them
    /// defined in the CSS Values and Units spec.
    ///
    /// [compatible]: https://www.w3.org/TR/css-values-4/#compat
    var numerators: [String] = []

    /// The number's denominator units.
    var denominators: [String] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// A SassScript color value, represented as red, green, and blue channels.
  struct RgbColor {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The color's red channel. Mandatory. May not be above 255.
    var red: UInt32 = 0

    /// The color's green channel. Mandatory. May not be above 255.
    var green: UInt32 = 0

    /// The color's blue channel. Mandatory. May not be above 255.
    var blue: UInt32 = 0

    /// The color's alpha channel. Mandatory. Must be between 0 and 1,
    /// inclusive.
    var alpha: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// A SassScript color value, represented as hue, saturation, and lightness channels.
  struct HslColor {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The color's hue. Mandatory.
    var hue: Double = 0

    /// The color's percent saturation. Mandatory. Must be between 0 and 100,
    /// inclusive.
    var saturation: Double = 0

    /// The color's percent lightness. Mandatory. Must be between 0 and 100,
    /// inclusive.
    var lightness: Double = 0

    /// The color's alpha channel. Mandatory. Must be between 0 and 1,
    /// inclusive.
    var alpha: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// A SassScript list value.
  struct List {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The type of separator for this list. Mandatory.
    var separator: Sass_EmbeddedProtocol_Value.List.Separator = .comma

    /// Whether this list has square brackets. Mandatory.
    var hasBrackets_p: Bool = false

    /// The elements of this list.
    var contents: [Sass_EmbeddedProtocol_Value] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Different types of separators a list can have.
    enum Separator: SwiftProtobuf.Enum {
      typealias RawValue = Int

      /// List elements are separated by a comma.
      case comma // = 0

      /// List elements are separated by whitespace.
      case space // = 1

      /// List elements are separated by a forward slash.
      case slash // = 2

      /// The list's separator hasn't yet been determined.
      ///
      /// Singleton lists and empty lists don't have separators defined. This
      /// means that list functions will prefer other lists' separators if
      /// possible.
      case undecided // = 3
      case UNRECOGNIZED(Int)

      init() {
        self = .comma
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .comma
        case 1: self = .space
        case 2: self = .slash
        case 3: self = .undecided
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .comma: return 0
        case .space: return 1
        case .slash: return 2
        case .undecided: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    init() {}
  }

  /// A SassScript map value.
  struct Map {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The entries in this map. The sending endpoint must guarantee that no two
    /// entries have the same key.
    var entries: [Sass_EmbeddedProtocol_Value.Map.Entry] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// A single key/value pair in the map.
    struct Entry {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The key this entry is associated with. Mandatory.
      var key: Sass_EmbeddedProtocol_Value {
        get {return _key ?? Sass_EmbeddedProtocol_Value()}
        set {_key = newValue}
      }
      /// Returns true if `key` has been explicitly set.
      var hasKey: Bool {return self._key != nil}
      /// Clears the value of `key`. Subsequent reads from it will return its default value.
      mutating func clearKey() {self._key = nil}

      /// The value associated with this key. Mandatory.
      var value: Sass_EmbeddedProtocol_Value {
        get {return _value ?? Sass_EmbeddedProtocol_Value()}
        set {_value = newValue}
      }
      /// Returns true if `value` has been explicitly set.
      var hasValue: Bool {return self._value != nil}
      /// Clears the value of `value`. Subsequent reads from it will return its default value.
      mutating func clearValue() {self._value = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _key: Sass_EmbeddedProtocol_Value? = nil
      fileprivate var _value: Sass_EmbeddedProtocol_Value? = nil
    }

    init() {}
  }

  /// A first-class function defined in the compiler. New `CompilerFunction`s may
  /// only be created by the compiler, but the host may pass `CompilerFunction`s
  /// back to the compiler as long as their IDs match IDs of functions received
  /// by the host during that same compilation.
  struct CompilerFunction {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A unique ID for this function. The compiler is responsible for generating
    /// this ID and ensuring it's unique across all functions passed to the host
    /// for this compilation. Mandatory.
    var id: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// An anonymous custom function defined in the host. New `HostFunction`s may
  /// only be created by the host, and `HostFunction`s may *never* be passed from
  /// the compiler to the host. The compiler must instead pass a
  /// `CompilerFunction` that wraps the `HostFunction`.
  struct HostFunction {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A unique ID for this function. The compiler must pass this ID as
    /// `OutboundRequest.FunctionCallRequest.id` when invoking this function. The
    /// host is responsible for generating this ID and ensuring it's unique
    /// across all functions for *all* compilations. Mandatory.
    var id: UInt32 = 0

    /// The signatures for this function. This must be a valid Sass function
    /// signature that could appear in after `@function` in a Sass stylesheet,
    /// such as `mix($color1, $color2, $weight: 50%)`. Mandatory.
    ///
    /// The compiler may not invoke the function by its name, since it's not
    /// guaranteed to be globally unique. However, it may use the name to
    /// generate the string representation of this function.
    var signature: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

#if swift(>=4.2)

extension Sass_EmbeddedProtocol_Value.Singleton: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sass_EmbeddedProtocol_Value.Singleton] = [
    .true,
    .false,
    .null,
  ]
}

extension Sass_EmbeddedProtocol_Value.List.Separator: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sass_EmbeddedProtocol_Value.List.Separator] = [
    .comma,
    .space,
    .slash,
    .undecided,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "sass.embedded_protocol"

extension Sass_EmbeddedProtocol_InboundMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InboundMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "compileRequest"),
    3: .same(proto: "canonicalizeResponse"),
    4: .same(proto: "importResponse"),
    5: .same(proto: "fileImportResponse"),
    6: .same(proto: "functionCallResponse"),
    7: .same(proto: "versionRequest"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: Sass_EmbeddedProtocol_InboundMessage.CompileRequest?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .compileRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .compileRequest(v)
        }
      }()
      case 3: try {
        var v: Sass_EmbeddedProtocol_InboundMessage.CanonicalizeResponse?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .canonicalizeResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .canonicalizeResponse(v)
        }
      }()
      case 4: try {
        var v: Sass_EmbeddedProtocol_InboundMessage.ImportResponse?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .importResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .importResponse(v)
        }
      }()
      case 5: try {
        var v: Sass_EmbeddedProtocol_InboundMessage.FileImportResponse?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .fileImportResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .fileImportResponse(v)
        }
      }()
      case 6: try {
        var v: Sass_EmbeddedProtocol_InboundMessage.FunctionCallResponse?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .functionCallResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .functionCallResponse(v)
        }
      }()
      case 7: try {
        var v: Sass_EmbeddedProtocol_InboundMessage.VersionRequest?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .versionRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .versionRequest(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.message {
    case .compileRequest?: try {
      guard case .compileRequest(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .canonicalizeResponse?: try {
      guard case .canonicalizeResponse(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .importResponse?: try {
      guard case .importResponse(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .fileImportResponse?: try {
      guard case .fileImportResponse(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .functionCallResponse?: try {
      guard case .functionCallResponse(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .versionRequest?: try {
      guard case .versionRequest(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_InboundMessage, rhs: Sass_EmbeddedProtocol_InboundMessage) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_InboundMessage.Syntax: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SCSS"),
    1: .same(proto: "INDENTED"),
    2: .same(proto: "CSS"),
  ]
}

extension Sass_EmbeddedProtocol_InboundMessage.VersionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_InboundMessage.protoMessageName + ".VersionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_InboundMessage.VersionRequest, rhs: Sass_EmbeddedProtocol_InboundMessage.VersionRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_InboundMessage.CompileRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_InboundMessage.protoMessageName + ".CompileRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "string"),
    3: .same(proto: "path"),
    4: .same(proto: "style"),
    5: .standard(proto: "source_map"),
    6: .same(proto: "importers"),
    7: .standard(proto: "global_functions"),
    8: .standard(proto: "alert_color"),
    9: .standard(proto: "alert_ascii"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      case 2: try {
        var v: Sass_EmbeddedProtocol_InboundMessage.CompileRequest.StringInput?
        var hadOneofValue = false
        if let current = self.input {
          hadOneofValue = true
          if case .string(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.input = .string(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.input != nil {try decoder.handleConflictingOneOf()}
          self.input = .path(v)
        }
      }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.style) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.sourceMap) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.importers) }()
      case 7: try { try decoder.decodeRepeatedStringField(value: &self.globalFunctions) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.alertColor) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.alertAscii) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.input {
    case .string?: try {
      guard case .string(let v)? = self.input else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .path?: try {
      guard case .path(let v)? = self.input else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if self.style != .expanded {
      try visitor.visitSingularEnumField(value: self.style, fieldNumber: 4)
    }
    if self.sourceMap != false {
      try visitor.visitSingularBoolField(value: self.sourceMap, fieldNumber: 5)
    }
    if !self.importers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.importers, fieldNumber: 6)
    }
    if !self.globalFunctions.isEmpty {
      try visitor.visitRepeatedStringField(value: self.globalFunctions, fieldNumber: 7)
    }
    if self.alertColor != false {
      try visitor.visitSingularBoolField(value: self.alertColor, fieldNumber: 8)
    }
    if self.alertAscii != false {
      try visitor.visitSingularBoolField(value: self.alertAscii, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_InboundMessage.CompileRequest, rhs: Sass_EmbeddedProtocol_InboundMessage.CompileRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.input != rhs.input {return false}
    if lhs.style != rhs.style {return false}
    if lhs.sourceMap != rhs.sourceMap {return false}
    if lhs.importers != rhs.importers {return false}
    if lhs.globalFunctions != rhs.globalFunctions {return false}
    if lhs.alertColor != rhs.alertColor {return false}
    if lhs.alertAscii != rhs.alertAscii {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_InboundMessage.CompileRequest.OutputStyle: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EXPANDED"),
    1: .same(proto: "COMPRESSED"),
  ]
}

extension Sass_EmbeddedProtocol_InboundMessage.CompileRequest.StringInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_InboundMessage.CompileRequest.protoMessageName + ".StringInput"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
    2: .same(proto: "url"),
    3: .same(proto: "syntax"),
    4: .same(proto: "importer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.source) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.syntax) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._importer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.source.isEmpty {
      try visitor.visitSingularStringField(value: self.source, fieldNumber: 1)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 2)
    }
    if self.syntax != .scss {
      try visitor.visitSingularEnumField(value: self.syntax, fieldNumber: 3)
    }
    if let v = self._importer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_InboundMessage.CompileRequest.StringInput, rhs: Sass_EmbeddedProtocol_InboundMessage.CompileRequest.StringInput) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.url != rhs.url {return false}
    if lhs.syntax != rhs.syntax {return false}
    if lhs._importer != rhs._importer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_InboundMessage.CompileRequest.Importer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_InboundMessage.CompileRequest.protoMessageName + ".Importer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .standard(proto: "importer_id"),
    3: .standard(proto: "file_importer_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.importer != nil {try decoder.handleConflictingOneOf()}
          self.importer = .path(v)
        }
      }()
      case 2: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.importer != nil {try decoder.handleConflictingOneOf()}
          self.importer = .importerID(v)
        }
      }()
      case 3: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.importer != nil {try decoder.handleConflictingOneOf()}
          self.importer = .fileImporterID(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.importer {
    case .path?: try {
      guard case .path(let v)? = self.importer else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .importerID?: try {
      guard case .importerID(let v)? = self.importer else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }()
    case .fileImporterID?: try {
      guard case .fileImporterID(let v)? = self.importer else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_InboundMessage.CompileRequest.Importer, rhs: Sass_EmbeddedProtocol_InboundMessage.CompileRequest.Importer) -> Bool {
    if lhs.importer != rhs.importer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_InboundMessage.CanonicalizeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_InboundMessage.protoMessageName + ".CanonicalizeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "url"),
    3: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.result != nil {try decoder.handleConflictingOneOf()}
          self.result = .url(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.result != nil {try decoder.handleConflictingOneOf()}
          self.result = .error(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.result {
    case .url?: try {
      guard case .url(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .error?: try {
      guard case .error(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_InboundMessage.CanonicalizeResponse, rhs: Sass_EmbeddedProtocol_InboundMessage.CanonicalizeResponse) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_InboundMessage.ImportResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_InboundMessage.protoMessageName + ".ImportResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "success"),
    3: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      case 2: try {
        var v: Sass_EmbeddedProtocol_InboundMessage.ImportResponse.ImportSuccess?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .success(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .success(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.result != nil {try decoder.handleConflictingOneOf()}
          self.result = .error(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.result {
    case .success?: try {
      guard case .success(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .error?: try {
      guard case .error(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_InboundMessage.ImportResponse, rhs: Sass_EmbeddedProtocol_InboundMessage.ImportResponse) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_InboundMessage.ImportResponse.ImportSuccess: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_InboundMessage.ImportResponse.protoMessageName + ".ImportSuccess"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contents"),
    2: .same(proto: "syntax"),
    3: .same(proto: "sourceMapUrl"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contents) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.syntax) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.sourceMapURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contents.isEmpty {
      try visitor.visitSingularStringField(value: self.contents, fieldNumber: 1)
    }
    if self.syntax != .scss {
      try visitor.visitSingularEnumField(value: self.syntax, fieldNumber: 2)
    }
    if !self.sourceMapURL.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceMapURL, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_InboundMessage.ImportResponse.ImportSuccess, rhs: Sass_EmbeddedProtocol_InboundMessage.ImportResponse.ImportSuccess) -> Bool {
    if lhs.contents != rhs.contents {return false}
    if lhs.syntax != rhs.syntax {return false}
    if lhs.sourceMapURL != rhs.sourceMapURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_InboundMessage.FileImportResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_InboundMessage.protoMessageName + ".FileImportResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "file_url"),
    3: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.result != nil {try decoder.handleConflictingOneOf()}
          self.result = .fileURL(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.result != nil {try decoder.handleConflictingOneOf()}
          self.result = .error(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.result {
    case .fileURL?: try {
      guard case .fileURL(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .error?: try {
      guard case .error(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_InboundMessage.FileImportResponse, rhs: Sass_EmbeddedProtocol_InboundMessage.FileImportResponse) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_InboundMessage.FunctionCallResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_InboundMessage.protoMessageName + ".FunctionCallResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "success"),
    3: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      case 2: try {
        var v: Sass_EmbeddedProtocol_Value?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .success(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .success(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.result != nil {try decoder.handleConflictingOneOf()}
          self.result = .error(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.result {
    case .success?: try {
      guard case .success(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .error?: try {
      guard case .error(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_InboundMessage.FunctionCallResponse, rhs: Sass_EmbeddedProtocol_InboundMessage.FunctionCallResponse) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_OutboundMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OutboundMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "compileResponse"),
    3: .same(proto: "logEvent"),
    4: .same(proto: "canonicalizeRequest"),
    5: .same(proto: "importRequest"),
    6: .same(proto: "fileImportRequest"),
    7: .same(proto: "functionCallRequest"),
    8: .same(proto: "versionResponse"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Sass_EmbeddedProtocol_ProtocolError?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .error(v)
        }
      }()
      case 2: try {
        var v: Sass_EmbeddedProtocol_OutboundMessage.CompileResponse?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .compileResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .compileResponse(v)
        }
      }()
      case 3: try {
        var v: Sass_EmbeddedProtocol_OutboundMessage.LogEvent?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .logEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .logEvent(v)
        }
      }()
      case 4: try {
        var v: Sass_EmbeddedProtocol_OutboundMessage.CanonicalizeRequest?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .canonicalizeRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .canonicalizeRequest(v)
        }
      }()
      case 5: try {
        var v: Sass_EmbeddedProtocol_OutboundMessage.ImportRequest?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .importRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .importRequest(v)
        }
      }()
      case 6: try {
        var v: Sass_EmbeddedProtocol_OutboundMessage.FileImportRequest?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .fileImportRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .fileImportRequest(v)
        }
      }()
      case 7: try {
        var v: Sass_EmbeddedProtocol_OutboundMessage.FunctionCallRequest?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .functionCallRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .functionCallRequest(v)
        }
      }()
      case 8: try {
        var v: Sass_EmbeddedProtocol_OutboundMessage.VersionResponse?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .versionResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .versionResponse(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.message {
    case .error?: try {
      guard case .error(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .compileResponse?: try {
      guard case .compileResponse(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .logEvent?: try {
      guard case .logEvent(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .canonicalizeRequest?: try {
      guard case .canonicalizeRequest(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .importRequest?: try {
      guard case .importRequest(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .fileImportRequest?: try {
      guard case .fileImportRequest(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .functionCallRequest?: try {
      guard case .functionCallRequest(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .versionResponse?: try {
      guard case .versionResponse(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_OutboundMessage, rhs: Sass_EmbeddedProtocol_OutboundMessage) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_OutboundMessage.VersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_OutboundMessage.protoMessageName + ".VersionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .same(proto: "id"),
    1: .standard(proto: "protocol_version"),
    2: .standard(proto: "compiler_version"),
    3: .standard(proto: "implementation_version"),
    4: .standard(proto: "implementation_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.protocolVersion) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.compilerVersion) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.implementationVersion) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.implementationName) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.protocolVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.protocolVersion, fieldNumber: 1)
    }
    if !self.compilerVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.compilerVersion, fieldNumber: 2)
    }
    if !self.implementationVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.implementationVersion, fieldNumber: 3)
    }
    if !self.implementationName.isEmpty {
      try visitor.visitSingularStringField(value: self.implementationName, fieldNumber: 4)
    }
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_OutboundMessage.VersionResponse, rhs: Sass_EmbeddedProtocol_OutboundMessage.VersionResponse) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.protocolVersion != rhs.protocolVersion {return false}
    if lhs.compilerVersion != rhs.compilerVersion {return false}
    if lhs.implementationVersion != rhs.implementationVersion {return false}
    if lhs.implementationName != rhs.implementationName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_OutboundMessage.CompileResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_OutboundMessage.protoMessageName + ".CompileResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "success"),
    3: .same(proto: "failure"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      case 2: try {
        var v: Sass_EmbeddedProtocol_OutboundMessage.CompileResponse.CompileSuccess?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .success(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .success(v)
        }
      }()
      case 3: try {
        var v: Sass_EmbeddedProtocol_OutboundMessage.CompileResponse.CompileFailure?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .failure(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .failure(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.result {
    case .success?: try {
      guard case .success(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .failure?: try {
      guard case .failure(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_OutboundMessage.CompileResponse, rhs: Sass_EmbeddedProtocol_OutboundMessage.CompileResponse) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_OutboundMessage.CompileResponse.CompileSuccess: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_OutboundMessage.CompileResponse.protoMessageName + ".CompileSuccess"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "css"),
    2: .standard(proto: "source_map"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.css) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sourceMap) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.css.isEmpty {
      try visitor.visitSingularStringField(value: self.css, fieldNumber: 1)
    }
    if !self.sourceMap.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceMap, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_OutboundMessage.CompileResponse.CompileSuccess, rhs: Sass_EmbeddedProtocol_OutboundMessage.CompileResponse.CompileSuccess) -> Bool {
    if lhs.css != rhs.css {return false}
    if lhs.sourceMap != rhs.sourceMap {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_OutboundMessage.CompileResponse.CompileFailure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_OutboundMessage.CompileResponse.protoMessageName + ".CompileFailure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
    2: .same(proto: "span"),
    3: .standard(proto: "stack_trace"),
    4: .same(proto: "formatted"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._span) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.stackTrace) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.formatted) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    if let v = self._span {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.stackTrace.isEmpty {
      try visitor.visitSingularStringField(value: self.stackTrace, fieldNumber: 3)
    }
    if !self.formatted.isEmpty {
      try visitor.visitSingularStringField(value: self.formatted, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_OutboundMessage.CompileResponse.CompileFailure, rhs: Sass_EmbeddedProtocol_OutboundMessage.CompileResponse.CompileFailure) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs._span != rhs._span {return false}
    if lhs.stackTrace != rhs.stackTrace {return false}
    if lhs.formatted != rhs.formatted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_OutboundMessage.LogEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_OutboundMessage.protoMessageName + ".LogEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "compilation_id"),
    2: .same(proto: "type"),
    3: .same(proto: "message"),
    4: .same(proto: "span"),
    5: .standard(proto: "stack_trace"),
    6: .same(proto: "formatted"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.compilationID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._span) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.stackTrace) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.formatted) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.compilationID != 0 {
      try visitor.visitSingularUInt32Field(value: self.compilationID, fieldNumber: 1)
    }
    if self.type != .warning {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 3)
    }
    if let v = self._span {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.stackTrace.isEmpty {
      try visitor.visitSingularStringField(value: self.stackTrace, fieldNumber: 5)
    }
    if !self.formatted.isEmpty {
      try visitor.visitSingularStringField(value: self.formatted, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_OutboundMessage.LogEvent, rhs: Sass_EmbeddedProtocol_OutboundMessage.LogEvent) -> Bool {
    if lhs.compilationID != rhs.compilationID {return false}
    if lhs.type != rhs.type {return false}
    if lhs.message != rhs.message {return false}
    if lhs._span != rhs._span {return false}
    if lhs.stackTrace != rhs.stackTrace {return false}
    if lhs.formatted != rhs.formatted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_OutboundMessage.LogEvent.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "WARNING"),
    1: .same(proto: "DEPRECATION_WARNING"),
    2: .same(proto: "DEBUG"),
  ]
}

extension Sass_EmbeddedProtocol_OutboundMessage.CanonicalizeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_OutboundMessage.protoMessageName + ".CanonicalizeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "compilation_id"),
    3: .standard(proto: "importer_id"),
    4: .same(proto: "url"),
    5: .same(proto: "fromImport"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.compilationID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.importerID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.fromImport) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    if self.compilationID != 0 {
      try visitor.visitSingularUInt32Field(value: self.compilationID, fieldNumber: 2)
    }
    if self.importerID != 0 {
      try visitor.visitSingularUInt32Field(value: self.importerID, fieldNumber: 3)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 4)
    }
    if self.fromImport != false {
      try visitor.visitSingularBoolField(value: self.fromImport, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_OutboundMessage.CanonicalizeRequest, rhs: Sass_EmbeddedProtocol_OutboundMessage.CanonicalizeRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.compilationID != rhs.compilationID {return false}
    if lhs.importerID != rhs.importerID {return false}
    if lhs.url != rhs.url {return false}
    if lhs.fromImport != rhs.fromImport {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_OutboundMessage.ImportRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_OutboundMessage.protoMessageName + ".ImportRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "compilation_id"),
    3: .standard(proto: "importer_id"),
    4: .same(proto: "url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.compilationID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.importerID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    if self.compilationID != 0 {
      try visitor.visitSingularUInt32Field(value: self.compilationID, fieldNumber: 2)
    }
    if self.importerID != 0 {
      try visitor.visitSingularUInt32Field(value: self.importerID, fieldNumber: 3)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_OutboundMessage.ImportRequest, rhs: Sass_EmbeddedProtocol_OutboundMessage.ImportRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.compilationID != rhs.compilationID {return false}
    if lhs.importerID != rhs.importerID {return false}
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_OutboundMessage.FileImportRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_OutboundMessage.protoMessageName + ".FileImportRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "compilation_id"),
    3: .standard(proto: "importer_id"),
    4: .same(proto: "url"),
    5: .same(proto: "fromImport"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.compilationID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.importerID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.fromImport) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    if self.compilationID != 0 {
      try visitor.visitSingularUInt32Field(value: self.compilationID, fieldNumber: 2)
    }
    if self.importerID != 0 {
      try visitor.visitSingularUInt32Field(value: self.importerID, fieldNumber: 3)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 4)
    }
    if self.fromImport != false {
      try visitor.visitSingularBoolField(value: self.fromImport, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_OutboundMessage.FileImportRequest, rhs: Sass_EmbeddedProtocol_OutboundMessage.FileImportRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.compilationID != rhs.compilationID {return false}
    if lhs.importerID != rhs.importerID {return false}
    if lhs.url != rhs.url {return false}
    if lhs.fromImport != rhs.fromImport {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_OutboundMessage.FunctionCallRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_OutboundMessage.protoMessageName + ".FunctionCallRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "compilation_id"),
    3: .same(proto: "name"),
    4: .standard(proto: "function_id"),
    5: .same(proto: "arguments"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.compilationID) }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.identifier != nil {try decoder.handleConflictingOneOf()}
          self.identifier = .name(v)
        }
      }()
      case 4: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.identifier != nil {try decoder.handleConflictingOneOf()}
          self.identifier = .functionID(v)
        }
      }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.arguments) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    if self.compilationID != 0 {
      try visitor.visitSingularUInt32Field(value: self.compilationID, fieldNumber: 2)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.identifier {
    case .name?: try {
      guard case .name(let v)? = self.identifier else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case .functionID?: try {
      guard case .functionID(let v)? = self.identifier else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    if !self.arguments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.arguments, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_OutboundMessage.FunctionCallRequest, rhs: Sass_EmbeddedProtocol_OutboundMessage.FunctionCallRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.compilationID != rhs.compilationID {return false}
    if lhs.identifier != rhs.identifier {return false}
    if lhs.arguments != rhs.arguments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_ProtocolError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProtocolError"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "id"),
    3: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .parse {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 2)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_ProtocolError, rhs: Sass_EmbeddedProtocol_ProtocolError) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.id != rhs.id {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_ProtocolError.ErrorType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PARSE"),
    1: .same(proto: "PARAMS"),
    2: .same(proto: "INTERNAL"),
  ]
}

extension Sass_EmbeddedProtocol_SourceSpan: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SourceSpan"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "start"),
    3: .same(proto: "end"),
    4: .same(proto: "url"),
    5: .same(proto: "context"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._start) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._end) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.context) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    if let v = self._start {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._end {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 4)
    }
    if !self.context.isEmpty {
      try visitor.visitSingularStringField(value: self.context, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_SourceSpan, rhs: Sass_EmbeddedProtocol_SourceSpan) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs._start != rhs._start {return false}
    if lhs._end != rhs._end {return false}
    if lhs.url != rhs.url {return false}
    if lhs.context != rhs.context {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_SourceSpan.SourceLocation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_SourceSpan.protoMessageName + ".SourceLocation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "offset"),
    2: .same(proto: "line"),
    3: .same(proto: "column"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.offset) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.line) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.column) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.offset != 0 {
      try visitor.visitSingularUInt32Field(value: self.offset, fieldNumber: 1)
    }
    if self.line != 0 {
      try visitor.visitSingularUInt32Field(value: self.line, fieldNumber: 2)
    }
    if self.column != 0 {
      try visitor.visitSingularUInt32Field(value: self.column, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_SourceSpan.SourceLocation, rhs: Sass_EmbeddedProtocol_SourceSpan.SourceLocation) -> Bool {
    if lhs.offset != rhs.offset {return false}
    if lhs.line != rhs.line {return false}
    if lhs.column != rhs.column {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_Value: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Value"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "string"),
    2: .same(proto: "number"),
    3: .standard(proto: "rgb_color"),
    4: .standard(proto: "hsl_color"),
    5: .same(proto: "list"),
    6: .same(proto: "map"),
    7: .same(proto: "singleton"),
    8: .standard(proto: "compiler_function"),
    9: .standard(proto: "host_function"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Sass_EmbeddedProtocol_Value.StringMessage?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .string(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .string(v)
        }
      }()
      case 2: try {
        var v: Sass_EmbeddedProtocol_Value.Number?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .number(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .number(v)
        }
      }()
      case 3: try {
        var v: Sass_EmbeddedProtocol_Value.RgbColor?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .rgbColor(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .rgbColor(v)
        }
      }()
      case 4: try {
        var v: Sass_EmbeddedProtocol_Value.HslColor?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .hslColor(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .hslColor(v)
        }
      }()
      case 5: try {
        var v: Sass_EmbeddedProtocol_Value.List?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .list(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .list(v)
        }
      }()
      case 6: try {
        var v: Sass_EmbeddedProtocol_Value.Map?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .map(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .map(v)
        }
      }()
      case 7: try {
        var v: Sass_EmbeddedProtocol_Value.Singleton?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .singleton(v)
        }
      }()
      case 8: try {
        var v: Sass_EmbeddedProtocol_Value.CompilerFunction?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .compilerFunction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .compilerFunction(v)
        }
      }()
      case 9: try {
        var v: Sass_EmbeddedProtocol_Value.HostFunction?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .hostFunction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .hostFunction(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.value {
    case .string?: try {
      guard case .string(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .number?: try {
      guard case .number(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .rgbColor?: try {
      guard case .rgbColor(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .hslColor?: try {
      guard case .hslColor(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .list?: try {
      guard case .list(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .map?: try {
      guard case .map(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .singleton?: try {
      guard case .singleton(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 7)
    }()
    case .compilerFunction?: try {
      guard case .compilerFunction(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .hostFunction?: try {
      guard case .hostFunction(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_Value, rhs: Sass_EmbeddedProtocol_Value) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_Value.Singleton: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TRUE"),
    1: .same(proto: "FALSE"),
    2: .same(proto: "NULL"),
  ]
}

extension Sass_EmbeddedProtocol_Value.StringMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_Value.protoMessageName + ".String"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "quoted"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.quoted) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    if self.quoted != false {
      try visitor.visitSingularBoolField(value: self.quoted, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_Value.StringMessage, rhs: Sass_EmbeddedProtocol_Value.StringMessage) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.quoted != rhs.quoted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_Value.Number: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_Value.protoMessageName + ".Number"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "numerators"),
    3: .same(proto: "denominators"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.value) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.numerators) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.denominators) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularDoubleField(value: self.value, fieldNumber: 1)
    }
    if !self.numerators.isEmpty {
      try visitor.visitRepeatedStringField(value: self.numerators, fieldNumber: 2)
    }
    if !self.denominators.isEmpty {
      try visitor.visitRepeatedStringField(value: self.denominators, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_Value.Number, rhs: Sass_EmbeddedProtocol_Value.Number) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.numerators != rhs.numerators {return false}
    if lhs.denominators != rhs.denominators {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_Value.RgbColor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_Value.protoMessageName + ".RgbColor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "red"),
    2: .same(proto: "green"),
    3: .same(proto: "blue"),
    4: .same(proto: "alpha"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.red) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.green) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.blue) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.alpha) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.red != 0 {
      try visitor.visitSingularUInt32Field(value: self.red, fieldNumber: 1)
    }
    if self.green != 0 {
      try visitor.visitSingularUInt32Field(value: self.green, fieldNumber: 2)
    }
    if self.blue != 0 {
      try visitor.visitSingularUInt32Field(value: self.blue, fieldNumber: 3)
    }
    if self.alpha != 0 {
      try visitor.visitSingularDoubleField(value: self.alpha, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_Value.RgbColor, rhs: Sass_EmbeddedProtocol_Value.RgbColor) -> Bool {
    if lhs.red != rhs.red {return false}
    if lhs.green != rhs.green {return false}
    if lhs.blue != rhs.blue {return false}
    if lhs.alpha != rhs.alpha {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_Value.HslColor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_Value.protoMessageName + ".HslColor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hue"),
    2: .same(proto: "saturation"),
    3: .same(proto: "lightness"),
    4: .same(proto: "alpha"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.hue) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.saturation) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.lightness) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.alpha) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.hue != 0 {
      try visitor.visitSingularDoubleField(value: self.hue, fieldNumber: 1)
    }
    if self.saturation != 0 {
      try visitor.visitSingularDoubleField(value: self.saturation, fieldNumber: 2)
    }
    if self.lightness != 0 {
      try visitor.visitSingularDoubleField(value: self.lightness, fieldNumber: 3)
    }
    if self.alpha != 0 {
      try visitor.visitSingularDoubleField(value: self.alpha, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_Value.HslColor, rhs: Sass_EmbeddedProtocol_Value.HslColor) -> Bool {
    if lhs.hue != rhs.hue {return false}
    if lhs.saturation != rhs.saturation {return false}
    if lhs.lightness != rhs.lightness {return false}
    if lhs.alpha != rhs.alpha {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_Value.List: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_Value.protoMessageName + ".List"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "separator"),
    2: .standard(proto: "has_brackets"),
    3: .same(proto: "contents"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.separator) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.hasBrackets_p) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.contents) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.separator != .comma {
      try visitor.visitSingularEnumField(value: self.separator, fieldNumber: 1)
    }
    if self.hasBrackets_p != false {
      try visitor.visitSingularBoolField(value: self.hasBrackets_p, fieldNumber: 2)
    }
    if !self.contents.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.contents, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_Value.List, rhs: Sass_EmbeddedProtocol_Value.List) -> Bool {
    if lhs.separator != rhs.separator {return false}
    if lhs.hasBrackets_p != rhs.hasBrackets_p {return false}
    if lhs.contents != rhs.contents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_Value.List.Separator: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "COMMA"),
    1: .same(proto: "SPACE"),
    2: .same(proto: "SLASH"),
    3: .same(proto: "UNDECIDED"),
  ]
}

extension Sass_EmbeddedProtocol_Value.Map: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_Value.protoMessageName + ".Map"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entries"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_Value.Map, rhs: Sass_EmbeddedProtocol_Value.Map) -> Bool {
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_Value.Map.Entry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_Value.Map.protoMessageName + ".Entry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._key) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._key {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_Value.Map.Entry, rhs: Sass_EmbeddedProtocol_Value.Map.Entry) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_Value.CompilerFunction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_Value.protoMessageName + ".CompilerFunction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_Value.CompilerFunction, rhs: Sass_EmbeddedProtocol_Value.CompilerFunction) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_Value.HostFunction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_Value.protoMessageName + ".HostFunction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.signature) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularStringField(value: self.signature, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_Value.HostFunction, rhs: Sass_EmbeddedProtocol_Value.HostFunction) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
