// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: embedded_sass.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019 Google Inc. Use of this source code is governed by an
// MIT-style license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

// This protocol buffer uses optional fields, which requires either [buf] or a
// [protoc] version 3.15 or later.
//
// [buf]: https://buf.build/
// [protoc]: https://github.com/protocolbuffers/protobuf#protobuf-compiler-installation

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Possible ways to format the CSS output. The compiler is not required to
/// support all possible options; if the host requests an unsupported style, the
/// compiler should choose the closest supported style.
enum Sass_EmbeddedProtocol_OutputStyle: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int

  /// Each selector and declaration is written on its own line.
  case expanded // = 0

  /// The entire stylesheet is written on a single line, with as few characters
  /// as possible.
  case compressed // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .expanded
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .expanded
    case 1: self = .compressed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .expanded: return 0
    case .compressed: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Sass_EmbeddedProtocol_OutputStyle] = [
    .expanded,
    .compressed,
  ]

}

/// Possible syntaxes for a Sass stylesheet.
enum Sass_EmbeddedProtocol_Syntax: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int

  /// The CSS-superset `.scss` syntax.
  case scss // = 0

  /// The indented `.sass` syntax.
  case indented // = 1

  /// Plain CSS syntax that doesn't support any special Sass features.
  case css // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .scss
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .scss
    case 1: self = .indented
    case 2: self = .css
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .scss: return 0
    case .indented: return 1
    case .css: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Sass_EmbeddedProtocol_Syntax] = [
    .scss,
    .indented,
    .css,
  ]

}

/// The possible types of [LogEvent].
enum Sass_EmbeddedProtocol_LogEventType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int

  /// A warning for something other than a deprecated Sass feature. Often emitted
  /// due to a stylesheet using the `@warn` rule.
  case warning // = 0

  /// A warning indicating that the stylesheet is using a deprecated Sass
  /// feature. Compilers should not add text like "deprecation warning" to
  /// deprecation warnings; it's up to the host to determine how to signal that
  /// to the user.
  case deprecationWarning // = 1

  /// A message generated by the user for their own debugging purposes.
  case debug // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .warning
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .warning
    case 1: self = .deprecationWarning
    case 2: self = .debug
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .warning: return 0
    case .deprecationWarning: return 1
    case .debug: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Sass_EmbeddedProtocol_LogEventType] = [
    .warning,
    .deprecationWarning,
    .debug,
  ]

}

/// Potential types of protocol errors.
enum Sass_EmbeddedProtocol_ProtocolErrorType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int

  /// A message was received that couldn't be decoded as an `InboundMessage` (for
  /// the compiler) or `OutboundMessage` (for the host).
  case parse // = 0

  /// A message was received that violated a documented restriction, such as not
  /// providing a mandatory field.
  case params // = 1

  /// Something unexpected went wrong within the endpoint.
  case `internal` // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .parse
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .parse
    case 1: self = .params
    case 2: self = .internal
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .parse: return 0
    case .params: return 1
    case .internal: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Sass_EmbeddedProtocol_ProtocolErrorType] = [
    .parse,
    .params,
    .internal,
  ]

}

/// Different types of separators a list can have.
enum Sass_EmbeddedProtocol_ListSeparator: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int

  /// List elements are separated by a comma.
  case comma // = 0

  /// List elements are separated by whitespace.
  case space // = 1

  /// List elements are separated by a forward slash.
  case slash // = 2

  /// The list's separator hasn't yet been determined. This is only allowed for
  /// singleton and empty lists.
  ///
  /// Singleton lists and empty lists don't have separators defined. This means
  /// that list functions will prefer other lists' separators if possible.
  case undecided // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .comma
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .comma
    case 1: self = .space
    case 2: self = .slash
    case 3: self = .undecided
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .comma: return 0
    case .space: return 1
    case .slash: return 2
    case .undecided: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Sass_EmbeddedProtocol_ListSeparator] = [
    .comma,
    .space,
    .slash,
    .undecided,
  ]

}

/// Singleton SassScript values that have no internal state.
enum Sass_EmbeddedProtocol_SingletonValue: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int

  /// The SassScript boolean true value.
  case `true` // = 0

  /// The SassScript boolean false value.
  case `false` // = 1

  /// The SassScript null value.
  case null // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .true
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .true
    case 1: self = .false
    case 2: self = .null
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .true: return 0
    case .false: return 1
    case .null: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Sass_EmbeddedProtocol_SingletonValue] = [
    .true,
    .false,
    .null,
  ]

}

/// An operator used in a calculation value's operation.
enum Sass_EmbeddedProtocol_CalculationOperator: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int

  /// The addition operator.
  case plus // = 0

  /// The subtraction operator.
  case minus // = 1

  /// The multiplication operator.
  case times // = 2

  /// The division operator.
  case divide // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .plus
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .plus
    case 1: self = .minus
    case 2: self = .times
    case 3: self = .divide
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .plus: return 0
    case .minus: return 1
    case .times: return 2
    case .divide: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Sass_EmbeddedProtocol_CalculationOperator] = [
    .plus,
    .minus,
    .times,
    .divide,
  ]

}

/// The wrapper type for all messages sent from the host to the compiler. This
/// provides a `oneof` that makes it possible to determine the type of each
/// inbound message.
struct Sass_EmbeddedProtocol_InboundMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The wrapped message. Mandatory.
  var message: Sass_EmbeddedProtocol_InboundMessage.OneOf_Message? = nil

  var compileRequest: Sass_EmbeddedProtocol_InboundMessage.CompileRequest {
    get {
      if case .compileRequest(let v)? = message {return v}
      return Sass_EmbeddedProtocol_InboundMessage.CompileRequest()
    }
    set {message = .compileRequest(newValue)}
  }

  var canonicalizeResponse: Sass_EmbeddedProtocol_InboundMessage.CanonicalizeResponse {
    get {
      if case .canonicalizeResponse(let v)? = message {return v}
      return Sass_EmbeddedProtocol_InboundMessage.CanonicalizeResponse()
    }
    set {message = .canonicalizeResponse(newValue)}
  }

  var importResponse: Sass_EmbeddedProtocol_InboundMessage.ImportResponse {
    get {
      if case .importResponse(let v)? = message {return v}
      return Sass_EmbeddedProtocol_InboundMessage.ImportResponse()
    }
    set {message = .importResponse(newValue)}
  }

  var fileImportResponse: Sass_EmbeddedProtocol_InboundMessage.FileImportResponse {
    get {
      if case .fileImportResponse(let v)? = message {return v}
      return Sass_EmbeddedProtocol_InboundMessage.FileImportResponse()
    }
    set {message = .fileImportResponse(newValue)}
  }

  var functionCallResponse: Sass_EmbeddedProtocol_InboundMessage.FunctionCallResponse {
    get {
      if case .functionCallResponse(let v)? = message {return v}
      return Sass_EmbeddedProtocol_InboundMessage.FunctionCallResponse()
    }
    set {message = .functionCallResponse(newValue)}
  }

  var versionRequest: Sass_EmbeddedProtocol_InboundMessage.VersionRequest {
    get {
      if case .versionRequest(let v)? = message {return v}
      return Sass_EmbeddedProtocol_InboundMessage.VersionRequest()
    }
    set {message = .versionRequest(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The wrapped message. Mandatory.
  enum OneOf_Message: Equatable, Sendable {
    case compileRequest(Sass_EmbeddedProtocol_InboundMessage.CompileRequest)
    case canonicalizeResponse(Sass_EmbeddedProtocol_InboundMessage.CanonicalizeResponse)
    case importResponse(Sass_EmbeddedProtocol_InboundMessage.ImportResponse)
    case fileImportResponse(Sass_EmbeddedProtocol_InboundMessage.FileImportResponse)
    case functionCallResponse(Sass_EmbeddedProtocol_InboundMessage.FunctionCallResponse)
    case versionRequest(Sass_EmbeddedProtocol_InboundMessage.VersionRequest)

  }

  /// A request for information about the version of the embedded compiler. The
  /// host can use this to provide diagnostic information to the user, to check
  /// which features the compiler supports, or to ensure that it's compatible
  /// with the same protocol version the compiler supports.
  struct VersionRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// This version request's id.
    var id: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// A request that compiles an entrypoint to CSS.
  struct CompileRequest: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The input stylesheet to parse. Mandatory.
    var input: OneOf_Input? {
      get {return _storage._input}
      set {_uniqueStorage()._input = newValue}
    }

    /// A stylesheet loaded from its contents.
    var string: Sass_EmbeddedProtocol_InboundMessage.CompileRequest.StringInput {
      get {
        if case .string(let v)? = _storage._input {return v}
        return Sass_EmbeddedProtocol_InboundMessage.CompileRequest.StringInput()
      }
      set {_uniqueStorage()._input = .string(newValue)}
    }

    /// A stylesheet loaded from the given path on the filesystem.
    var path: String {
      get {
        if case .path(let v)? = _storage._input {return v}
        return String()
      }
      set {_uniqueStorage()._input = .path(newValue)}
    }

    /// How to format the CSS output.
    var style: Sass_EmbeddedProtocol_OutputStyle {
      get {return _storage._style}
      set {_uniqueStorage()._style = newValue}
    }

    /// Whether to generate a source map. Note that this will *not* add a source
    /// map comment to the stylesheet; that's up to the host or its users.
    var sourceMap: Bool {
      get {return _storage._sourceMap}
      set {_uniqueStorage()._sourceMap = newValue}
    }

    /// Importers (including load paths on the filesystem) to use when resolving
    /// imports that can't be resolved relative to the file that contains it. Each
    /// importer is checked in order until one recognizes the imported URL.
    var importers: [Sass_EmbeddedProtocol_InboundMessage.CompileRequest.Importer] {
      get {return _storage._importers}
      set {_uniqueStorage()._importers = newValue}
    }

    /// Signatures for custom global functions whose behavior is defined by the
    /// host.
    ///
    /// If this is not a valid Sass function signature that could appear after
    /// `@function` in a Sass stylesheet (such as `mix($color1, $color2, $weight:
    /// 50%)`), or if it conflicts with a function name that's built into the
    /// Sass language, the compiler must treat the compilation as failed.
    ///
    /// Compilers must ensure that pure-Sass functions take precedence over
    /// custom global functions.
    var globalFunctions: [String] {
      get {return _storage._globalFunctions}
      set {_uniqueStorage()._globalFunctions = newValue}
    }

    /// Whether to use terminal colors in the formatted message of errors and
    /// logs.
    var alertColor: Bool {
      get {return _storage._alertColor}
      set {_uniqueStorage()._alertColor = newValue}
    }

    /// Whether to encode the formatted message of errors and logs in ASCII.
    var alertAscii: Bool {
      get {return _storage._alertAscii}
      set {_uniqueStorage()._alertAscii = newValue}
    }

    /// Whether to report all deprecation warnings or only the first few ones.
    /// If this is `false`, the compiler may choose not to send events for
    /// repeated deprecation warnings. If this is `true`, the compiler must emit
    /// an event for every deprecation warning it encounters.
    var verbose: Bool {
      get {return _storage._verbose}
      set {_uniqueStorage()._verbose = newValue}
    }

    /// Whether to omit events for deprecation warnings coming from dependencies
    /// (files loaded from a different importer than the input).
    var quietDeps: Bool {
      get {return _storage._quietDeps}
      set {_uniqueStorage()._quietDeps = newValue}
    }

    /// Whether to include sources in the generated sourcemap
    var sourceMapIncludeSources: Bool {
      get {return _storage._sourceMapIncludeSources}
      set {_uniqueStorage()._sourceMapIncludeSources = newValue}
    }

    /// Whether to emit a `@charset`/BOM for non-ASCII stylesheets.
    var charset: Bool {
      get {return _storage._charset}
      set {_uniqueStorage()._charset = newValue}
    }

    /// Whether to silently suppresses all `LogEvent`s.
    var silent: Bool {
      get {return _storage._silent}
      set {_uniqueStorage()._silent = newValue}
    }

    /// Deprecation IDs or versions to treat as fatal.
    var fatalDeprecation: [String] {
      get {return _storage._fatalDeprecation}
      set {_uniqueStorage()._fatalDeprecation = newValue}
    }

    /// Deprecation IDs to ignore.
    var silenceDeprecation: [String] {
      get {return _storage._silenceDeprecation}
      set {_uniqueStorage()._silenceDeprecation = newValue}
    }

    /// Deprecation IDs to opt into early.
    var futureDeprecation: [String] {
      get {return _storage._futureDeprecation}
      set {_uniqueStorage()._futureDeprecation = newValue}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The input stylesheet to parse. Mandatory.
    enum OneOf_Input: Equatable, Sendable {
      /// A stylesheet loaded from its contents.
      case string(Sass_EmbeddedProtocol_InboundMessage.CompileRequest.StringInput)
      /// A stylesheet loaded from the given path on the filesystem.
      case path(String)

    }

    /// An input stylesheet provided as plain text, rather than loaded from the
    /// filesystem.
    struct StringInput: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The contents of the stylesheet.
      var source: String = String()

      /// The location from which `source` was loaded. If this is empty, it
      /// indicates that the URL is unknown.
      ///
      /// This must be a canonical URL recognized by `importer`, if it's passed.
      var url: String = String()

      /// The syntax to use to parse `source`.
      var syntax: Sass_EmbeddedProtocol_Syntax = .scss

      /// The importer to use to resolve imports relative to `url`.
      var importer: Sass_EmbeddedProtocol_InboundMessage.CompileRequest.Importer {
        get {return _importer ?? Sass_EmbeddedProtocol_InboundMessage.CompileRequest.Importer()}
        set {_importer = newValue}
      }
      /// Returns true if `importer` has been explicitly set.
      var hasImporter: Bool {return self._importer != nil}
      /// Clears the value of `importer`. Subsequent reads from it will return its default value.
      mutating func clearImporter() {self._importer = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _importer: Sass_EmbeddedProtocol_InboundMessage.CompileRequest.Importer? = nil
    }

    /// A wrapper message that represents either a user-defined importer or a
    /// load path on disk. This must be a wrapper because `oneof` types can't be
    /// `repeated`.
    struct Importer: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The possible types of importer. Mandatory.
      var importer: Sass_EmbeddedProtocol_InboundMessage.CompileRequest.Importer.OneOf_Importer? = nil

      /// A built-in importer that loads Sass files within the given directory
      /// on disk.
      var path: String {
        get {
          if case .path(let v)? = importer {return v}
          return String()
        }
        set {importer = .path(newValue)}
      }

      /// A unique ID for a user-defined importer. This ID will be included in
      /// outbound `CanonicalizeRequest` and `ImportRequest` messages to
      /// indicate which importer is being called. The host is responsible for
      /// generating this ID and ensuring that it's unique across all
      /// importers registered for this compilation.
      var importerID: UInt32 {
        get {
          if case .importerID(let v)? = importer {return v}
          return 0
        }
        set {importer = .importerID(newValue)}
      }

      /// A unique ID for a special kind of user-defined importer that tells
      /// the compiler where to look for files on the physical filesystem, but
      /// leaves the details of resolving partials and extensions and loading
      /// the file from disk up to the compiler itself.
      ///
      /// This ID will be included in outbound `FileImportRequest` messages to
      /// indicate which importer is being called. The host is responsible for
      /// generating this ID and ensuring that it's unique across all importers
      /// registered for this compilation.
      var fileImporterID: UInt32 {
        get {
          if case .fileImporterID(let v)? = importer {return v}
          return 0
        }
        set {importer = .fileImporterID(newValue)}
      }

      /// The [Node.js package importer], which is a built-in Package Importer
      /// with an associated `entry_point_directory` that resolves `pkg:` URLs
      /// using the standards and conventions of the Node ecosystem.
      ///
      /// [Node.js package importer]: https://github.com/sass/sass/tree/main/spec/modules.md#node-package-importer
      var nodePackageImporter: Sass_EmbeddedProtocol_NodePackageImporter {
        get {
          if case .nodePackageImporter(let v)? = importer {return v}
          return Sass_EmbeddedProtocol_NodePackageImporter()
        }
        set {importer = .nodePackageImporter(newValue)}
      }

      /// The set of URL schemes that are considered *non-canonical* for this
      /// importer. This must be empty unless `importer.importer_id` is set.
      ///
      /// If any element of this contains a character other than a lowercase
      /// ASCII letter, an ASCII numeral, U+002B (`+`), U+002D (`-`), or U+002E
      /// (`.`), the compiler must treat the compilation as failed.
      var nonCanonicalScheme: [String] = []

      var unknownFields = SwiftProtobuf.UnknownStorage()

      /// The possible types of importer. Mandatory.
      enum OneOf_Importer: Equatable, Sendable {
        /// A built-in importer that loads Sass files within the given directory
        /// on disk.
        case path(String)
        /// A unique ID for a user-defined importer. This ID will be included in
        /// outbound `CanonicalizeRequest` and `ImportRequest` messages to
        /// indicate which importer is being called. The host is responsible for
        /// generating this ID and ensuring that it's unique across all
        /// importers registered for this compilation.
        case importerID(UInt32)
        /// A unique ID for a special kind of user-defined importer that tells
        /// the compiler where to look for files on the physical filesystem, but
        /// leaves the details of resolving partials and extensions and loading
        /// the file from disk up to the compiler itself.
        ///
        /// This ID will be included in outbound `FileImportRequest` messages to
        /// indicate which importer is being called. The host is responsible for
        /// generating this ID and ensuring that it's unique across all importers
        /// registered for this compilation.
        case fileImporterID(UInt32)
        /// The [Node.js package importer], which is a built-in Package Importer
        /// with an associated `entry_point_directory` that resolves `pkg:` URLs
        /// using the standards and conventions of the Node ecosystem.
        ///
        /// [Node.js package importer]: https://github.com/sass/sass/tree/main/spec/modules.md#node-package-importer
        case nodePackageImporter(Sass_EmbeddedProtocol_NodePackageImporter)

      }

      init() {}
    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// A response indicating the result of canonicalizing an imported URL.
  struct CanonicalizeResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: UInt32 = 0

    /// The result of canonicalization. If this is unset, it indicates that the
    /// importer either did not recognize the URL, or could not find a stylesheet
    /// at the location it referred to. Optional.
    var result: Sass_EmbeddedProtocol_InboundMessage.CanonicalizeResponse.OneOf_Result? = nil

    /// The successfully canonicalized URL.
    ///
    /// If this is not an absolute URL (including scheme), the compiler must
    /// treat that as an error thrown by the importer. If this URL's scheme is
    /// an `Importer.non_canonical_scheme` for the importer being invoked, the
    /// compiler must treat that as an error thrown by the importer.
    var url: String {
      get {
        if case .url(let v)? = result {return v}
        return String()
      }
      set {result = .url(newValue)}
    }

    /// An error message explaining why canonicalization failed.
    ///
    /// This indicates that a stylesheet was found, but a canonical URL for it
    /// could not be determined. If no stylesheet was found, `result` should be
    /// `null` instead.
    var error: String {
      get {
        if case .error(let v)? = result {return v}
        return String()
      }
      set {result = .error(newValue)}
    }

    /// Whether `containing_url` in `CanonicalizeRequest` is unused.
    ///
    /// The compiler can cache the `CanonicalizeResponse` if the `containing_url`
    /// is unused.
    ///
    /// The default value is `false`, thus when the value is not set by the host,
    /// the `CanonicalizeResponse` will not be cached by the compiler.
    var containingURLUnused: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The result of canonicalization. If this is unset, it indicates that the
    /// importer either did not recognize the URL, or could not find a stylesheet
    /// at the location it referred to. Optional.
    enum OneOf_Result: Equatable, Sendable {
      /// The successfully canonicalized URL.
      ///
      /// If this is not an absolute URL (including scheme), the compiler must
      /// treat that as an error thrown by the importer. If this URL's scheme is
      /// an `Importer.non_canonical_scheme` for the importer being invoked, the
      /// compiler must treat that as an error thrown by the importer.
      case url(String)
      /// An error message explaining why canonicalization failed.
      ///
      /// This indicates that a stylesheet was found, but a canonical URL for it
      /// could not be determined. If no stylesheet was found, `result` should be
      /// `null` instead.
      case error(String)

    }

    init() {}
  }

  /// A response indicating the result of importing a canonical URL.
  struct ImportResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: UInt32 = 0

    /// The result of loading the URL. If this is unset, it indicates that the
    /// importer either did not recognize the URL, or could not find a stylesheet
    /// at the location it referred to. Optional.
    var result: Sass_EmbeddedProtocol_InboundMessage.ImportResponse.OneOf_Result? = nil

    /// The contents of the loaded stylesheet.
    var success: Sass_EmbeddedProtocol_InboundMessage.ImportResponse.ImportSuccess {
      get {
        if case .success(let v)? = result {return v}
        return Sass_EmbeddedProtocol_InboundMessage.ImportResponse.ImportSuccess()
      }
      set {result = .success(newValue)}
    }

    /// An error message explaining why the URL could not be loaded.
    var error: String {
      get {
        if case .error(let v)? = result {return v}
        return String()
      }
      set {result = .error(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The result of loading the URL. If this is unset, it indicates that the
    /// importer either did not recognize the URL, or could not find a stylesheet
    /// at the location it referred to. Optional.
    enum OneOf_Result: Equatable, Sendable {
      /// The contents of the loaded stylesheet.
      case success(Sass_EmbeddedProtocol_InboundMessage.ImportResponse.ImportSuccess)
      /// An error message explaining why the URL could not be loaded.
      case error(String)

    }

    /// The stylesheet's contents were loaded successfully.
    struct ImportSuccess: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The text of the stylesheet.
      var contents: String = String()

      /// The syntax of `contents`.
      var syntax: Sass_EmbeddedProtocol_Syntax = .scss

      /// An absolute, browser-accessible URL indicating the resolved location of
      /// the imported stylesheet.
      ///
      /// This should be a `file:` URL if one is available, but an `http:` URL is
      /// acceptable as well. If no URL is supplied, a `data:` URL is generated
      /// automatically from `contents`.
      ///
      /// If this is provided and is not an absolute URL (including scheme) the
      /// compiler must treat that as an error thrown by the importer.
      var sourceMapURL: String {
        get {return _sourceMapURL ?? String()}
        set {_sourceMapURL = newValue}
      }
      /// Returns true if `sourceMapURL` has been explicitly set.
      var hasSourceMapURL: Bool {return self._sourceMapURL != nil}
      /// Clears the value of `sourceMapURL`. Subsequent reads from it will return its default value.
      mutating func clearSourceMapURL() {self._sourceMapURL = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _sourceMapURL: String? = nil
    }

    init() {}
  }

  /// A response indicating the result of redirecting a URL to the filesystem.
  struct FileImportResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: UInt32 = 0

    /// The result of loading the URL. An unset result indicates that the
    /// importer did not recognize the URL and other importers or load paths
    /// should be tried. Optional.
    var result: Sass_EmbeddedProtocol_InboundMessage.FileImportResponse.OneOf_Result? = nil

    /// The absolute `file:` URL to look for the file on the physical
    /// filesystem.
    ///
    /// The compiler must verify to the best of its ability that this URL
    /// follows the format for an absolute `file:` URL on the current operating
    /// system without a hostname. If it doesn't, the compiler must treat that
    /// as an error thrown by the importer. See
    /// https://en.wikipedia.org/wiki/File_URI_scheme for details on the
    /// format.
    ///
    /// The compiler must handle turning this into a canonical URL by resolving
    /// it for partials, file extensions, and index files. The compiler must
    /// then loading the contents of the resulting canonical URL from the
    /// filesystem.
    var fileURL: String {
      get {
        if case .fileURL(let v)? = result {return v}
        return String()
      }
      set {result = .fileURL(newValue)}
    }

    /// An error message explaining why the URL could not be loaded.
    var error: String {
      get {
        if case .error(let v)? = result {return v}
        return String()
      }
      set {result = .error(newValue)}
    }

    /// Whether `containing_url` in `FileImportRequest` is unused.
    ///
    /// The compiler can cache the `FileImportResponse` if the `containing_url`
    /// is unused.
    ///
    /// The default value is `false`, thus when the value is not set by the host,
    /// the `FileImportResponse` will not be cached by the compiler.
    var containingURLUnused: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The result of loading the URL. An unset result indicates that the
    /// importer did not recognize the URL and other importers or load paths
    /// should be tried. Optional.
    enum OneOf_Result: Equatable, Sendable {
      /// The absolute `file:` URL to look for the file on the physical
      /// filesystem.
      ///
      /// The compiler must verify to the best of its ability that this URL
      /// follows the format for an absolute `file:` URL on the current operating
      /// system without a hostname. If it doesn't, the compiler must treat that
      /// as an error thrown by the importer. See
      /// https://en.wikipedia.org/wiki/File_URI_scheme for details on the
      /// format.
      ///
      /// The compiler must handle turning this into a canonical URL by resolving
      /// it for partials, file extensions, and index files. The compiler must
      /// then loading the contents of the resulting canonical URL from the
      /// filesystem.
      case fileURL(String)
      /// An error message explaining why the URL could not be loaded.
      case error(String)

    }

    init() {}
  }

  /// A response indicating the result of calling a custom Sass function defined
  /// in the host.
  struct FunctionCallResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: UInt32 = 0

    /// The result of calling the function. Mandatory.
    var result: Sass_EmbeddedProtocol_InboundMessage.FunctionCallResponse.OneOf_Result? = nil

    /// The return value of a successful function call.
    var success: Sass_EmbeddedProtocol_Value {
      get {
        if case .success(let v)? = result {return v}
        return Sass_EmbeddedProtocol_Value()
      }
      set {result = .success(newValue)}
    }

    /// An error message explaining why the function call failed.
    var error: String {
      get {
        if case .error(let v)? = result {return v}
        return String()
      }
      set {result = .error(newValue)}
    }

    /// The IDs of all `Value.ArgumentList`s in `FunctionCallRequest.arguments`
    /// whose keywords were accessed. See `Value.ArgumentList` for details. This
    /// may not include the special value `0` and it may not include multiple
    /// instances of the same ID.
    var accessedArgumentLists: [UInt32] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The result of calling the function. Mandatory.
    enum OneOf_Result: Equatable, Sendable {
      /// The return value of a successful function call.
      case success(Sass_EmbeddedProtocol_Value)
      /// An error message explaining why the function call failed.
      case error(String)

    }

    init() {}
  }

  init() {}
}

/// The wrapper type for all messages sent from the compiler to the host. This
/// provides a `oneof` that makes it possible to determine the type of each
/// outbound message.
struct Sass_EmbeddedProtocol_OutboundMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The wrapped message. Mandatory.
  var message: Sass_EmbeddedProtocol_OutboundMessage.OneOf_Message? = nil

  var error: Sass_EmbeddedProtocol_ProtocolError {
    get {
      if case .error(let v)? = message {return v}
      return Sass_EmbeddedProtocol_ProtocolError()
    }
    set {message = .error(newValue)}
  }

  var compileResponse: Sass_EmbeddedProtocol_OutboundMessage.CompileResponse {
    get {
      if case .compileResponse(let v)? = message {return v}
      return Sass_EmbeddedProtocol_OutboundMessage.CompileResponse()
    }
    set {message = .compileResponse(newValue)}
  }

  var logEvent: Sass_EmbeddedProtocol_OutboundMessage.LogEvent {
    get {
      if case .logEvent(let v)? = message {return v}
      return Sass_EmbeddedProtocol_OutboundMessage.LogEvent()
    }
    set {message = .logEvent(newValue)}
  }

  var canonicalizeRequest: Sass_EmbeddedProtocol_OutboundMessage.CanonicalizeRequest {
    get {
      if case .canonicalizeRequest(let v)? = message {return v}
      return Sass_EmbeddedProtocol_OutboundMessage.CanonicalizeRequest()
    }
    set {message = .canonicalizeRequest(newValue)}
  }

  var importRequest: Sass_EmbeddedProtocol_OutboundMessage.ImportRequest {
    get {
      if case .importRequest(let v)? = message {return v}
      return Sass_EmbeddedProtocol_OutboundMessage.ImportRequest()
    }
    set {message = .importRequest(newValue)}
  }

  var fileImportRequest: Sass_EmbeddedProtocol_OutboundMessage.FileImportRequest {
    get {
      if case .fileImportRequest(let v)? = message {return v}
      return Sass_EmbeddedProtocol_OutboundMessage.FileImportRequest()
    }
    set {message = .fileImportRequest(newValue)}
  }

  var functionCallRequest: Sass_EmbeddedProtocol_OutboundMessage.FunctionCallRequest {
    get {
      if case .functionCallRequest(let v)? = message {return v}
      return Sass_EmbeddedProtocol_OutboundMessage.FunctionCallRequest()
    }
    set {message = .functionCallRequest(newValue)}
  }

  var versionResponse: Sass_EmbeddedProtocol_OutboundMessage.VersionResponse {
    get {
      if case .versionResponse(let v)? = message {return v}
      return Sass_EmbeddedProtocol_OutboundMessage.VersionResponse()
    }
    set {message = .versionResponse(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The wrapped message. Mandatory.
  enum OneOf_Message: Equatable, Sendable {
    case error(Sass_EmbeddedProtocol_ProtocolError)
    case compileResponse(Sass_EmbeddedProtocol_OutboundMessage.CompileResponse)
    case logEvent(Sass_EmbeddedProtocol_OutboundMessage.LogEvent)
    case canonicalizeRequest(Sass_EmbeddedProtocol_OutboundMessage.CanonicalizeRequest)
    case importRequest(Sass_EmbeddedProtocol_OutboundMessage.ImportRequest)
    case fileImportRequest(Sass_EmbeddedProtocol_OutboundMessage.FileImportRequest)
    case functionCallRequest(Sass_EmbeddedProtocol_OutboundMessage.FunctionCallRequest)
    case versionResponse(Sass_EmbeddedProtocol_OutboundMessage.VersionResponse)

  }

  /// A response that contains the version of the embedded compiler.
  struct VersionResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// This version request's id.
    var id: UInt32 = 0

    /// The version of the embedded protocol, in semver format.
    var protocolVersion: String = String()

    /// The version of the embedded compiler package. This has no guaranteed
    /// format, although compilers are encouraged to use semver.
    var compilerVersion: String = String()

    /// The version of the Sass implementation that the embedded compiler wraps.
    /// This has no guaranteed format, although Sass implementations are
    /// encouraged to use semver.
    var implementationVersion: String = String()

    /// The name of the Sass implementation that the embedded compiler wraps.
    var implementationName: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// A response that contains the result of a compilation.
  struct CompileResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The success or failure result of the compilation. Mandatory.
    var result: Sass_EmbeddedProtocol_OutboundMessage.CompileResponse.OneOf_Result? = nil

    /// The result of a successful compilation.
    var success: Sass_EmbeddedProtocol_OutboundMessage.CompileResponse.CompileSuccess {
      get {
        if case .success(let v)? = result {return v}
        return Sass_EmbeddedProtocol_OutboundMessage.CompileResponse.CompileSuccess()
      }
      set {result = .success(newValue)}
    }

    /// The result of a failed compilation.
    var failure: Sass_EmbeddedProtocol_OutboundMessage.CompileResponse.CompileFailure {
      get {
        if case .failure(let v)? = result {return v}
        return Sass_EmbeddedProtocol_OutboundMessage.CompileResponse.CompileFailure()
      }
      set {result = .failure(newValue)}
    }

    /// The canonical URLs of all source files loaded during the compilation.
    ///
    /// The compiler must ensure that each canonical URL appears only once in
    /// this list. This must include the entrypoint file's URL if either
    /// `CompileRequest.input.path` or `CompileRequest.StringInput.url` was
    /// passed.
    var loadedUrls: [String] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The success or failure result of the compilation. Mandatory.
    enum OneOf_Result: Equatable, Sendable {
      /// The result of a successful compilation.
      case success(Sass_EmbeddedProtocol_OutboundMessage.CompileResponse.CompileSuccess)
      /// The result of a failed compilation.
      case failure(Sass_EmbeddedProtocol_OutboundMessage.CompileResponse.CompileFailure)

    }

    /// A message indicating that the Sass file was successfully compiled to CSS.
    struct CompileSuccess: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The compiled CSS.
      var css: String = String()

      /// The JSON-encoded source map, or the empty string if
      /// `CompileRequest.source_map` was `false`.
      ///
      /// The compiler must not add a `"file"` key to this source map. It's the
      /// host's (or the host's user's) responsibility to determine how the
      /// generated CSS can be reached from the source map.
      var sourceMap: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    /// A message indicating that the Sass file could not be successfully
    /// compiled to CSS.
    struct CompileFailure: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// A message describing the reason for the failure.
      var message: String = String()

      /// The span associated with the failure.
      var span: Sass_EmbeddedProtocol_SourceSpan {
        get {return _span ?? Sass_EmbeddedProtocol_SourceSpan()}
        set {_span = newValue}
      }
      /// Returns true if `span` has been explicitly set.
      var hasSpan: Bool {return self._span != nil}
      /// Clears the value of `span`. Subsequent reads from it will return its default value.
      mutating func clearSpan() {self._span = nil}

      /// The stack trace associated with the failure.
      ///
      /// The empty string indicates that no stack trace is available. Otherwise,
      /// the format of this stack trace is not specified and is likely to be
      /// inconsistent between implementations.
      var stackTrace: String = String()

      /// A formatted, human-readable string that contains the message, span
      /// (if available), and trace (if available). The format of this string is
      /// not specified and is likely to be inconsistent between implementations.
      var formatted: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _span: Sass_EmbeddedProtocol_SourceSpan? = nil
    }

    init() {}
  }

  /// An event indicating that a message should be displayed to the user.
  struct LogEvent: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: Sass_EmbeddedProtocol_LogEventType = .warning

    /// The text of the message.
    var message: String = String()

    /// The span associated with this message.
    var span: Sass_EmbeddedProtocol_SourceSpan {
      get {return _span ?? Sass_EmbeddedProtocol_SourceSpan()}
      set {_span = newValue}
    }
    /// Returns true if `span` has been explicitly set.
    var hasSpan: Bool {return self._span != nil}
    /// Clears the value of `span`. Subsequent reads from it will return its default value.
    mutating func clearSpan() {self._span = nil}

    /// The stack trace associated with this message.
    ///
    /// The empty string indicates that no stack trace is available. Otherwise,
    /// the format of this stack trace is not specified and is likely to be
    /// inconsistent between implementations.
    var stackTrace: String = String()

    /// A formatted, human-readable string that contains the message, span (if
    /// available), and trace (if available). The format of this string is not
    /// specified and is likely to be inconsistent between implementations.
    var formatted: String = String()

    /// The deprecation ID for this warning, if type is DEPRECATION_WARNING.
    var deprecationType: String {
      get {return _deprecationType ?? String()}
      set {_deprecationType = newValue}
    }
    /// Returns true if `deprecationType` has been explicitly set.
    var hasDeprecationType: Bool {return self._deprecationType != nil}
    /// Clears the value of `deprecationType`. Subsequent reads from it will return its default value.
    mutating func clearDeprecationType() {self._deprecationType = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _span: Sass_EmbeddedProtocol_SourceSpan? = nil
    fileprivate var _deprecationType: String? = nil
  }

  /// A request for a custom importer to convert an imported URL to its canonical
  /// format.
  ///
  /// If the URL is not recognized by this importer, or if no stylesheet is found
  /// at that URL, `CanonicalizeResponse.result` must be `null`. Otherwise, the
  /// importer must return an absolute URL, including a scheme.
  ///
  /// > The host's documentation should encourage the use of file importers (via
  /// > `CompileRequest.Importer.file_importer_id`, `FileImportRequest`, and
  /// > `FileImportResponse`) for any importers that simply refer to files on
  /// > disk. This will allow Sass to handle the logic of resolving partials,
  /// > file extensions, and index files.
  ///
  /// If Sass has already loaded a stylesheet with the returned canonical URL, it
  /// re-uses the existing parse tree. This means that importers must ensure that
  /// the same canonical URL always refers to the same stylesheet, *even across
  /// different importers*. Importers must also ensure that any canonicalized
  /// URLs they return can be passed back to `CanonicalizeRequest` and will be
  /// returned unchanged.
  ///
  /// If this importer's URL format supports file extensions, it should
  /// canonicalize them the same way as the default filesystem importer:
  ///
  /// * The importer should look for stylesheets by adding the prefix `_` to the
  ///   URL's basename, and by adding the extensions `.sass` and `.scss` if the
  ///   URL doesn't already have one of those extensions. For example, if the URL
  ///   was `foo/bar/baz`, the importer would look for:
  ///
  ///   * `foo/bar/baz.sass`
  ///   * `foo/bar/baz.scss`
  ///   * `foo/bar/_baz.sass`
  ///   * `foo/bar/_baz.scss`
  ///
  ///   If the URL was foo/bar/baz.scss, the importer would just look for:
  ///
  ///   * `foo/bar/baz.scss`
  ///   * `foo/bar/_baz.scss`
  ///
  ///   If the importer finds a stylesheet at more than one of these URLs, it
  ///   should respond with a `CanonicalizeResponse.result.error` indicating that
  ///   the import is ambiguous. Note that if the extension is explicitly
  ///   specified, a stylesheet with another extension may exist without error.
  ///
  /// * If none of the possible paths is valid, the importer should perform the
  ///   same resolution on the URL followed by `/index`. In the example above, it
  ///   would look for:
  ///
  ///   * `foo/bar/baz/_index.sass`
  ///   * `foo/bar/baz/index.sass`
  ///   * `foo/bar/baz/_index.scss`
  ///   * `foo/bar/baz/index.scss`
  ///
  ///   As above, if the importer finds a stylesheet at more than one of these
  ///   URLs, it should respond with a `CanonicalizeResponse.result.error`
  ///   indicating that the import is ambiguous.
  struct CanonicalizeRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: UInt32 = 0

    /// The unique ID of the importer being invoked. This must match an importer
    /// ID passed to this compilation in `CompileRequest.importers` or
    /// `CompileRequest.input.string.importer`.
    var importerID: UInt32 = 0

    /// The URL of the import to be canonicalized. This may be either absolute or
    /// relative.
    ///
    /// When loading a URL, the compiler must first try resolving that URL
    /// relative to the canonical URL of the current file, and canonicalizing the
    /// result using the importer that loaded the current file. If this returns
    /// `null`, the compiler must then try canonicalizing the original URL with
    /// each importer in order until one returns something other than `null`.
    /// That is the result of the import.
    var url: String = String()

    /// Whether this request comes from an `@import` rule.
    ///
    /// When evaluating `@import` rules, URLs should canonicalize to an
    /// [import-only file] if one exists for the URL being canonicalized.
    /// Otherwise, canonicalization should be identical for `@import` and `@use`
    /// rules.
    ///
    /// [import-only file]: https://sass-lang.com/documentation/at-rules/import#import-only-files
    var fromImport: Bool = false

    /// The canonical URL of the [current source file] that contained the load
    /// to be canonicalized.
    ///
    /// [current source file]: ../spec.md#current-source-file
    ///
    /// The compiler must set this if and only if `url` is relative or its
    /// scheme is an `Importer.non_canonical_scheme` for the importer being
    /// invoked, unless the current source file has no canonical URL.
    ///
    /// [non-canonical-proto]: #non_canonical_scheme
    var containingURL: String {
      get {return _containingURL ?? String()}
      set {_containingURL = newValue}
    }
    /// Returns true if `containingURL` has been explicitly set.
    var hasContainingURL: Bool {return self._containingURL != nil}
    /// Clears the value of `containingURL`. Subsequent reads from it will return its default value.
    mutating func clearContainingURL() {self._containingURL = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _containingURL: String? = nil
  }

  /// A request for a custom importer to load the contents of a stylesheet.
  struct ImportRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: UInt32 = 0

    /// The unique ID of the importer being invoked. This must match an
    /// `Importer.importer_id` passed to this compilation in
    /// `CompileRequest.importers` or `CompileRequest.input.string.importer`.
    var importerID: UInt32 = 0

    /// The canonical URL of the import. This is guaranteed to be a URL returned
    /// by a `CanonicalizeRequest` to this importer.
    var url: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// A request for a custom filesystem importer to load the contents of a
  /// stylesheet.
  ///
  /// A filesystem importer is represented in the compiler as an [importer]. When
  /// the importer is invoked with a string `string`:
  ///
  /// [importer]: https://github.com/sass/sass/tree/main/spec/modules.md#importer
  ///
  /// * If `string` is an absolute URL whose scheme is `file`:
  ///
  ///   * Let `url` be string.
  ///
  /// * Otherwise:
  ///
  ///   * Let `fromImport` be `true` if the importer is being run for an
  ///     `@import` and `false` otherwise.
  ///
  ///   * Let `containingUrl` be the canonical URL of the [current source file]
  ///     if it has one, or undefined otherwise.
  ///
  ///
  ///   * Let `response` be the result of sending a `FileImportRequest` with
  ///     `string` as its `url`, `fromImport` as `from_import`, and
  ///     `containingUrl` as `containing_url`.
  ///
  ///   * If `response.result` is null, return null.
  ///
  ///   * Otherwise, if `response.result.error` is set, throw an error.
  ///
  ///   * Otherwise, let `url` be `response.result.file_url`.
  ///
  /// * Let `resolved` be the result of [resolving `url`].
  ///
  /// * If `resolved` is null, return null.
  ///
  /// * Let `text` be the contents of the file at `resolved`.
  ///
  /// * Let `syntax` be:
  ///   * "scss" if `url` ends in `.scss`.
  ///   * "indented" if `url` ends in `.sass`.
  ///   * "css" if `url` ends in `.css`.
  ///
  ///   > The algorithm for resolving a `file:` URL guarantees that `url` will have
  ///   > one of these extensions.
  ///
  /// * Return `text`, `syntax`, and `resolved`.
  ///
  /// [current source file]: ../spec.md#current-source-file
  /// [resolving `url`]: https://github.com/sass/sass/tree/main/spec/modules.md#resolving-a-file-url
  struct FileImportRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: UInt32 = 0

    /// The unique ID of the importer being invoked. This must match an
    /// `Importer.file_importer_id` passed to this compilation in
    /// `CompileRequest.importers` or `CompileRequest.input.string.importer`.
    var importerID: UInt32 = 0

    /// The (non-canonicalized) URL of the import.
    var url: String = String()

    /// Whether this request comes from an `@import` rule.
    ///
    /// When evaluating `@import` rules, filesystem importers should load an
    /// [import-only file] if one exists for the URL being canonicalized.
    /// Otherwise, canonicalization should be identical for `@import` and `@use`
    /// rules.
    ///
    /// [import-only file]: https://sass-lang.com/documentation/at-rules/import#import-only-files
    var fromImport: Bool = false

    /// The canonical URL of the [current source file] that contained the load
    /// being resolved. The compiler must set this unless the current source file
    /// has no canonical URL.
    var containingURL: String {
      get {return _containingURL ?? String()}
      set {_containingURL = newValue}
    }
    /// Returns true if `containingURL` has been explicitly set.
    var hasContainingURL: Bool {return self._containingURL != nil}
    /// Clears the value of `containingURL`. Subsequent reads from it will return its default value.
    mutating func clearContainingURL() {self._containingURL = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _containingURL: String? = nil
  }

  /// A request to invoke a custom Sass function and return its result.
  struct FunctionCallRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: UInt32 = 0

    /// An identifier that indicates which function to invoke. Mandatory.
    var identifier: Sass_EmbeddedProtocol_OutboundMessage.FunctionCallRequest.OneOf_Identifier? = nil

    /// The name of the function to invoke.
    ///
    /// This must match the name of a function signature the host passed to the
    /// corresponding `CompileRequest.global_functions` call, including hyphens
    /// and underscores.
    var name: String {
      get {
        if case .name(let v)? = identifier {return v}
        return String()
      }
      set {identifier = .name(newValue)}
    }

    /// The opaque ID of the function to invoke.
    ///
    /// This must match the ID of a `Value.HostFunction` that the host passed
    /// to the compiler.
    var functionID: UInt32 {
      get {
        if case .functionID(let v)? = identifier {return v}
        return 0
      }
      set {identifier = .functionID(newValue)}
    }

    /// The arguments passed to the function, in the order they appear in the
    /// function signature passed to `CompileRequest.global_functions`.
    ///
    /// The compiler must ensure that a valid number of arguments are passed for
    /// the given signature, that default argument values are instantiated
    /// appropriately, and that variable argument lists (`$args...`) are passed
    /// as `Value.ArgumentList`s.
    var arguments: [Sass_EmbeddedProtocol_Value] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// An identifier that indicates which function to invoke. Mandatory.
    enum OneOf_Identifier: Equatable, Sendable {
      /// The name of the function to invoke.
      ///
      /// This must match the name of a function signature the host passed to the
      /// corresponding `CompileRequest.global_functions` call, including hyphens
      /// and underscores.
      case name(String)
      /// The opaque ID of the function to invoke.
      ///
      /// This must match the ID of a `Value.HostFunction` that the host passed
      /// to the compiler.
      case functionID(UInt32)

    }

    init() {}
  }

  init() {}
}

/// An error reported when an endpoint violates the embedded Sass protocol.
struct Sass_EmbeddedProtocol_ProtocolError: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Sass_EmbeddedProtocol_ProtocolErrorType = .parse

  /// The ID of the request that had an error. This MUST be `4294967295` if the
  /// request ID couldn't be determined, or if the error is being reported for a
  /// response or an event.
  var id: UInt32 = 0

  /// A human-readable message providing more detail about the error.
  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A chunk of a source file.
struct Sass_EmbeddedProtocol_SourceSpan: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The text covered by the source span. Compilers must guarantee that this is
  /// the text between `start.offset` and `end.offset` in the source file
  /// referred to by `url`.
  var text: String = String()

  /// The location of the first character in this span.
  var start: Sass_EmbeddedProtocol_SourceSpan.SourceLocation {
    get {return _start ?? Sass_EmbeddedProtocol_SourceSpan.SourceLocation()}
    set {_start = newValue}
  }
  /// Returns true if `start` has been explicitly set.
  var hasStart: Bool {return self._start != nil}
  /// Clears the value of `start`. Subsequent reads from it will return its default value.
  mutating func clearStart() {self._start = nil}

  /// The location of the first character after this span.
  ///
  /// If this is omitted, it indicates that the span is empty and points
  /// immediately before `start`. In that case, `text` must be empty.
  ///
  /// This must not point to a location before `start`.
  var end: Sass_EmbeddedProtocol_SourceSpan.SourceLocation {
    get {return _end ?? Sass_EmbeddedProtocol_SourceSpan.SourceLocation()}
    set {_end = newValue}
  }
  /// Returns true if `end` has been explicitly set.
  var hasEnd: Bool {return self._end != nil}
  /// Clears the value of `end`. Subsequent reads from it will return its default value.
  mutating func clearEnd() {self._end = nil}

  /// The URL of the file to which this span refers.
  ///
  /// This may be empty, indicating that the span refers to a
  /// `CompileRequest.StringInput` file that doesn't specify a URL.
  var url: String = String()

  /// Additional source text surrounding this span.
  ///
  /// If this isn't empty, it must contain `text`. Furthermore, `text` must begin
  /// at column `start.column` of a line in `context`.
  ///
  /// This usually contains the full lines the span begins and ends on if the
  /// span itself doesn't cover the full lines.
  var context: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A single point in a source file.
  struct SourceLocation: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The 0-based offset of this location within the source file.
    var offset: UInt32 = 0

    /// The 0-based line number of this location within the source file.
    var line: UInt32 = 0

    /// The 0-based column number of this location within its line.
    var column: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _start: Sass_EmbeddedProtocol_SourceSpan.SourceLocation? = nil
  fileprivate var _end: Sass_EmbeddedProtocol_SourceSpan.SourceLocation? = nil
}

/// A SassScript value, passed to and returned by functions.
struct Sass_EmbeddedProtocol_Value: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The value itself. Mandatory.
  ///
  /// This is wrapped in a message type rather than used directly to reduce
  /// repetition, and because oneofs can't be repeated.
  var value: Sass_EmbeddedProtocol_Value.OneOf_Value? = nil

  var string: Sass_EmbeddedProtocol_Value.StringMessage {
    get {
      if case .string(let v)? = value {return v}
      return Sass_EmbeddedProtocol_Value.StringMessage()
    }
    set {value = .string(newValue)}
  }

  var number: Sass_EmbeddedProtocol_Value.Number {
    get {
      if case .number(let v)? = value {return v}
      return Sass_EmbeddedProtocol_Value.Number()
    }
    set {value = .number(newValue)}
  }

  var list: Sass_EmbeddedProtocol_Value.List {
    get {
      if case .list(let v)? = value {return v}
      return Sass_EmbeddedProtocol_Value.List()
    }
    set {value = .list(newValue)}
  }

  var map: Sass_EmbeddedProtocol_Value.Map {
    get {
      if case .map(let v)? = value {return v}
      return Sass_EmbeddedProtocol_Value.Map()
    }
    set {value = .map(newValue)}
  }

  var singleton: Sass_EmbeddedProtocol_SingletonValue {
    get {
      if case .singleton(let v)? = value {return v}
      return .true
    }
    set {value = .singleton(newValue)}
  }

  var compilerFunction: Sass_EmbeddedProtocol_Value.CompilerFunction {
    get {
      if case .compilerFunction(let v)? = value {return v}
      return Sass_EmbeddedProtocol_Value.CompilerFunction()
    }
    set {value = .compilerFunction(newValue)}
  }

  var hostFunction: Sass_EmbeddedProtocol_Value.HostFunction {
    get {
      if case .hostFunction(let v)? = value {return v}
      return Sass_EmbeddedProtocol_Value.HostFunction()
    }
    set {value = .hostFunction(newValue)}
  }

  var argumentList: Sass_EmbeddedProtocol_Value.ArgumentList {
    get {
      if case .argumentList(let v)? = value {return v}
      return Sass_EmbeddedProtocol_Value.ArgumentList()
    }
    set {value = .argumentList(newValue)}
  }

  var calculation: Sass_EmbeddedProtocol_Value.Calculation {
    get {
      if case .calculation(let v)? = value {return v}
      return Sass_EmbeddedProtocol_Value.Calculation()
    }
    set {value = .calculation(newValue)}
  }

  var compilerMixin: Sass_EmbeddedProtocol_Value.CompilerMixin {
    get {
      if case .compilerMixin(let v)? = value {return v}
      return Sass_EmbeddedProtocol_Value.CompilerMixin()
    }
    set {value = .compilerMixin(newValue)}
  }

  var color: Sass_EmbeddedProtocol_Value.Color {
    get {
      if case .color(let v)? = value {return v}
      return Sass_EmbeddedProtocol_Value.Color()
    }
    set {value = .color(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The value itself. Mandatory.
  ///
  /// This is wrapped in a message type rather than used directly to reduce
  /// repetition, and because oneofs can't be repeated.
  enum OneOf_Value: Equatable, Sendable {
    case string(Sass_EmbeddedProtocol_Value.StringMessage)
    case number(Sass_EmbeddedProtocol_Value.Number)
    case list(Sass_EmbeddedProtocol_Value.List)
    case map(Sass_EmbeddedProtocol_Value.Map)
    case singleton(Sass_EmbeddedProtocol_SingletonValue)
    case compilerFunction(Sass_EmbeddedProtocol_Value.CompilerFunction)
    case hostFunction(Sass_EmbeddedProtocol_Value.HostFunction)
    case argumentList(Sass_EmbeddedProtocol_Value.ArgumentList)
    case calculation(Sass_EmbeddedProtocol_Value.Calculation)
    case compilerMixin(Sass_EmbeddedProtocol_Value.CompilerMixin)
    case color(Sass_EmbeddedProtocol_Value.Color)

  }

  /// A SassScript string value.
  struct StringMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The contents of the string.
    var text: String = String()

    /// Whether the string is quoted or unquoted.
    var quoted: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// A SassScript number value.
  struct Number: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The number's numeric value.
    var value: Double = 0

    /// The number's numerator units.
    ///
    /// The endpoint sending the number must ensure that no numerator units are
    /// [compatible][] with any denominator units. Such compatible units must be
    /// simplified away according to the multiplicative factor between them
    /// defined in the CSS Values and Units spec.
    ///
    /// [compatible]: https://www.w3.org/TR/css-values-4/#compat
    var numerators: [String] = []

    /// The number's denominator units.
    var denominators: [String] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// A SassScript color value.
  struct Color: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The name of a known color space.
    var space: String = String()

    /// The value of the first channel associated with `space`. A [missing]
    /// channel is represented by an unset value.
    ///
    /// [missing]: types/color.md#missing-components
    var channel1: Double {
      get {return _channel1 ?? 0}
      set {_channel1 = newValue}
    }
    /// Returns true if `channel1` has been explicitly set.
    var hasChannel1: Bool {return self._channel1 != nil}
    /// Clears the value of `channel1`. Subsequent reads from it will return its default value.
    mutating func clearChannel1() {self._channel1 = nil}

    /// The value of the second channel associated with `space`. A [missing]
    /// channel is represented by an unset value.
    ///
    /// [missing]: types/color.md#missing-components
    var channel2: Double {
      get {return _channel2 ?? 0}
      set {_channel2 = newValue}
    }
    /// Returns true if `channel2` has been explicitly set.
    var hasChannel2: Bool {return self._channel2 != nil}
    /// Clears the value of `channel2`. Subsequent reads from it will return its default value.
    mutating func clearChannel2() {self._channel2 = nil}

    /// The value of the third channel associated with `space`. A [missing]
    /// channel is represented by an unset value.
    ///
    /// [missing]: types/color.md#missing-components
    var channel3: Double {
      get {return _channel3 ?? 0}
      set {_channel3 = newValue}
    }
    /// Returns true if `channel3` has been explicitly set.
    var hasChannel3: Bool {return self._channel3 != nil}
    /// Clears the value of `channel3`. Subsequent reads from it will return its default value.
    mutating func clearChannel3() {self._channel3 = nil}

    /// The color's alpha channel. Mandatory. Must be between 0 and 1, inclusive.
    /// A [missing] channel is represented by an unset value.
    ///
    /// [missing]: types/color.md#missing-components
    var alpha: Double {
      get {return _alpha ?? 0}
      set {_alpha = newValue}
    }
    /// Returns true if `alpha` has been explicitly set.
    var hasAlpha: Bool {return self._alpha != nil}
    /// Clears the value of `alpha`. Subsequent reads from it will return its default value.
    mutating func clearAlpha() {self._alpha = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _channel1: Double? = nil
    fileprivate var _channel2: Double? = nil
    fileprivate var _channel3: Double? = nil
    fileprivate var _alpha: Double? = nil
  }

  /// A SassScript list value.
  struct List: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The type of separator for this list. Mandatory.
    var separator: Sass_EmbeddedProtocol_ListSeparator = .comma

    /// Whether this list has square brackets. Mandatory.
    var hasBrackets_p: Bool = false

    /// The elements of this list.
    var contents: [Sass_EmbeddedProtocol_Value] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// A SassScript map value.
  struct Map: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The entries in this map. The sending endpoint must guarantee that no two
    /// entries have the same key.
    var entries: [Sass_EmbeddedProtocol_Value.Map.Entry] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// A single key/value pair in the map.
    struct Entry: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The key this entry is associated with. Mandatory.
      var key: Sass_EmbeddedProtocol_Value {
        get {return _key ?? Sass_EmbeddedProtocol_Value()}
        set {_key = newValue}
      }
      /// Returns true if `key` has been explicitly set.
      var hasKey: Bool {return self._key != nil}
      /// Clears the value of `key`. Subsequent reads from it will return its default value.
      mutating func clearKey() {self._key = nil}

      /// The value associated with this key. Mandatory.
      var value: Sass_EmbeddedProtocol_Value {
        get {return _value ?? Sass_EmbeddedProtocol_Value()}
        set {_value = newValue}
      }
      /// Returns true if `value` has been explicitly set.
      var hasValue: Bool {return self._value != nil}
      /// Clears the value of `value`. Subsequent reads from it will return its default value.
      mutating func clearValue() {self._value = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _key: Sass_EmbeddedProtocol_Value? = nil
      fileprivate var _value: Sass_EmbeddedProtocol_Value? = nil
    }

    init() {}
  }

  /// A first-class function defined in the compiler. New `CompilerFunction`s may
  /// only be created by the compiler, but the host may pass `CompilerFunction`s
  /// back to the compiler as long as their IDs match IDs of functions received
  /// by the host during that same compilation.
  struct CompilerFunction: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A unique ID for this function. The compiler is responsible for generating
    /// this ID and ensuring it's unique across all functions passed to the host
    /// for this compilation. Mandatory.
    var id: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// An anonymous custom function defined in the host. New `HostFunction`s may
  /// only be created by the host, and `HostFunction`s may *never* be passed from
  /// the compiler to the host. The compiler must instead pass a
  /// `CompilerFunction` that wraps the `HostFunction`.
  struct HostFunction: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A unique ID for this function. The compiler must pass this ID as
    /// `OutboundRequest.FunctionCallRequest.id` when invoking this function. The
    /// host is responsible for generating this ID and ensuring it's unique
    /// across all functions for *all* compilations. Mandatory.
    var id: UInt32 = 0

    /// The signature for this function. Mandatory.
    ///
    /// If this isn't a valid Sass function signature that could appear after
    /// `@function` in a Sass stylesheet (such as `mix($color1, $color2, $weight:
    /// 50%)`), the compiler must treat it as though the function that returned
    /// this `HostFunction` threw an error.
    ///
    /// > This ensures that the host doesn't need to be able to correctly parse
    /// > the entire function declaration syntax.
    ///
    /// The compiler may not invoke the function by its name, since it's not
    /// guaranteed to be globally unique. However, it may use the name to
    /// generate the string representation of this function.
    var signature: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// A first-class mixin defined in the compiler. New `CompilerMixin`s may
  /// only be created by the compiler, but the host may pass `CompilerMixin`s
  /// back to the compiler as long as their IDs match IDs of mixins received
  /// by the host during that same compilation.
  struct CompilerMixin: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A unique ID for this mixin. The compiler is responsible for generating
    /// this ID and ensuring it's unique across all mixins passed to the host
    /// for this compilation. Mandatory.
    var id: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// A SassScript argument list value. This represents rest arguments passed to
  /// a function's `$arg...` parameter. Unlike a normal `List`, an argument list
  /// has an associated keywords map which tracks keyword arguments passed in
  /// alongside positional arguments.
  ///
  /// For each `ArgumentList` in `FunctionCallRequest.arguments` (including those
  /// nested within `List`s and `Map`s), the host must track whether its keyword
  /// arguments were accessed by the user. If they were, it must add its
  /// `ArgumentList.id` to `FunctionCallResponse.accessed_argument_lists`.
  ///
  /// The compiler must treat every `ArgumentList` whose `ArgumentList.id`
  /// appears in `FunctionCallResponse.accessed_argument_lists` as though it had
  /// been passed to `meta.keywords()`.
  struct ArgumentList: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// An ID for this argument list that's unique within the scope of a given
    /// `FunctionCallRequest`.
    ///
    /// The special ID `0` is reserved for `ArgumentList`s created by the host,
    /// and may not be used by the compiler. These `ArgumentList`s do not need to
    /// have their IDs added to `FunctionCallResponse.accessed_argument_lists`,
    /// and the compiler should treat them as though their keywords have always
    /// been accessed.
    var id: UInt32 = 0

    /// The type of separator for this list. The compiler must set this, but
    /// the host may omit it for `ArgumentList`s that were originally created by
    /// the compiler (that is, those with a non-0 ID).
    var separator: Sass_EmbeddedProtocol_ListSeparator = .comma

    /// The argument list's positional contents. The compiler must set this, but
    /// the host may omit it for `ArgumentList`s that were originally created by
    /// the compiler (that is, those with a non-0 ID).
    var contents: [Sass_EmbeddedProtocol_Value] = []

    /// The argument list's keywords. The compiler must set this, but the host
    /// may omit it for `ArgumentList`s that were originally created by the
    /// compiler (that is, those with a non-0 ID).
    var keywords: Dictionary<String,Sass_EmbeddedProtocol_Value> = [:]

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// A SassScript calculation value. The compiler must send fully [simplified]
  /// calculations, meaning that simplifying it again will produce the same
  /// calculation. The host is not required to simplify calculations.
  ///
  /// [simplified]: https://github.com/sass/sass/tree/main/spec/types/calculation.md#simplifying-a-calculation
  ///
  /// The compiler must simplify any calculations it receives from the host
  /// before returning them from a function. If this simplification produces an
  /// error, it should be treated as though the function call threw that error.
  /// It should *not* be treated as a protocol error.
  struct Calculation: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The calculation's name. Mandatory. The host may only set this to names
    /// that the Sass specification uses to create calculations.
    var name: String = String()

    /// The calculation's arguments. Mandatory. The host must use exactly the
    /// number of arguments used by the Sass specification for calculations with
    /// the given `name`.
    var arguments: [Sass_EmbeddedProtocol_Value.Calculation.CalculationValue] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// A single component of a calculation expression.
    struct CalculationValue: @unchecked Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The value of the component. Mandatory.
      var value: OneOf_Value? {
        get {return _storage._value}
        set {_uniqueStorage()._value = newValue}
      }

      var number: Sass_EmbeddedProtocol_Value.Number {
        get {
          if case .number(let v)? = _storage._value {return v}
          return Sass_EmbeddedProtocol_Value.Number()
        }
        set {_uniqueStorage()._value = .number(newValue)}
      }

      /// An unquoted string, as from a function like `var()` or `env()`.
      var string: String {
        get {
          if case .string(let v)? = _storage._value {return v}
          return String()
        }
        set {_uniqueStorage()._value = .string(newValue)}
      }

      /// An unquoted string as created by interpolation for
      /// backwards-compatibility with older Sass syntax.
      ///
      /// The compiler must treat this as identical to a `string` option whose
      /// value is `"(" + interpolation + ")"`.
      ///
      /// This field is deprecated and hosts should avoid using it.
      var interpolation: String {
        get {
          if case .interpolation(let v)? = _storage._value {return v}
          return String()
        }
        set {_uniqueStorage()._value = .interpolation(newValue)}
      }

      var operation: Sass_EmbeddedProtocol_Value.Calculation.CalculationOperation {
        get {
          if case .operation(let v)? = _storage._value {return v}
          return Sass_EmbeddedProtocol_Value.Calculation.CalculationOperation()
        }
        set {_uniqueStorage()._value = .operation(newValue)}
      }

      var calculation: Sass_EmbeddedProtocol_Value.Calculation {
        get {
          if case .calculation(let v)? = _storage._value {return v}
          return Sass_EmbeddedProtocol_Value.Calculation()
        }
        set {_uniqueStorage()._value = .calculation(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      /// The value of the component. Mandatory.
      enum OneOf_Value: Equatable, Sendable {
        case number(Sass_EmbeddedProtocol_Value.Number)
        /// An unquoted string, as from a function like `var()` or `env()`.
        case string(String)
        /// An unquoted string as created by interpolation for
        /// backwards-compatibility with older Sass syntax.
        ///
        /// The compiler must treat this as identical to a `string` option whose
        /// value is `"(" + interpolation + ")"`.
        ///
        /// This field is deprecated and hosts should avoid using it.
        case interpolation(String)
        case operation(Sass_EmbeddedProtocol_Value.Calculation.CalculationOperation)
        case calculation(Sass_EmbeddedProtocol_Value.Calculation)

      }

      init() {}

      fileprivate var _storage = _StorageClass.defaultInstance
    }

    /// A binary operation that appears in a calculation.
    struct CalculationOperation: @unchecked Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The operator to perform.
      var `operator`: Sass_EmbeddedProtocol_CalculationOperator {
        get {return _storage._operator}
        set {_uniqueStorage()._operator = newValue}
      }

      /// The left-hand side of the operation.
      var left: Sass_EmbeddedProtocol_Value.Calculation.CalculationValue {
        get {return _storage._left ?? Sass_EmbeddedProtocol_Value.Calculation.CalculationValue()}
        set {_uniqueStorage()._left = newValue}
      }
      /// Returns true if `left` has been explicitly set.
      var hasLeft: Bool {return _storage._left != nil}
      /// Clears the value of `left`. Subsequent reads from it will return its default value.
      mutating func clearLeft() {_uniqueStorage()._left = nil}

      /// The right-hand side of the operation.
      var right: Sass_EmbeddedProtocol_Value.Calculation.CalculationValue {
        get {return _storage._right ?? Sass_EmbeddedProtocol_Value.Calculation.CalculationValue()}
        set {_uniqueStorage()._right = newValue}
      }
      /// Returns true if `right` has been explicitly set.
      var hasRight: Bool {return _storage._right != nil}
      /// Clears the value of `right`. Subsequent reads from it will return its default value.
      mutating func clearRight() {_uniqueStorage()._right = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _storage = _StorageClass.defaultInstance
    }

    init() {}
  }

  init() {}
}

/// The built-in Node.js Package Importer, which is a Package Importer that
/// resolves using the standards and conventions of the Node.js ecosystem. It
/// enables a `pkg:` URL scheme for usage with `@use` that directs an
/// implementation to resolve a URL within a dependency.
struct Sass_EmbeddedProtocol_NodePackageImporter: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The absolute path to associate with the Node Package Importer, with
  /// semantics identical to the [entryPointDirectory option] in the JavaScript
  /// API.
  ///
  /// [entryPointDirectory option]: https://sass-lang.com/documentation/js-api/classes/NodePackageImporter.html#constructor
  var entryPointDirectory: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "sass.embedded_protocol"

extension Sass_EmbeddedProtocol_OutputStyle: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EXPANDED"),
    1: .same(proto: "COMPRESSED"),
  ]
}

extension Sass_EmbeddedProtocol_Syntax: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SCSS"),
    1: .same(proto: "INDENTED"),
    2: .same(proto: "CSS"),
  ]
}

extension Sass_EmbeddedProtocol_LogEventType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "WARNING"),
    1: .same(proto: "DEPRECATION_WARNING"),
    2: .same(proto: "DEBUG"),
  ]
}

extension Sass_EmbeddedProtocol_ProtocolErrorType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PARSE"),
    1: .same(proto: "PARAMS"),
    2: .same(proto: "INTERNAL"),
  ]
}

extension Sass_EmbeddedProtocol_ListSeparator: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "COMMA"),
    1: .same(proto: "SPACE"),
    2: .same(proto: "SLASH"),
    3: .same(proto: "UNDECIDED"),
  ]
}

extension Sass_EmbeddedProtocol_SingletonValue: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TRUE"),
    1: .same(proto: "FALSE"),
    2: .same(proto: "NULL"),
  ]
}

extension Sass_EmbeddedProtocol_CalculationOperator: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PLUS"),
    1: .same(proto: "MINUS"),
    2: .same(proto: "TIMES"),
    3: .same(proto: "DIVIDE"),
  ]
}

extension Sass_EmbeddedProtocol_InboundMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InboundMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "compile_request"),
    3: .standard(proto: "canonicalize_response"),
    4: .standard(proto: "import_response"),
    5: .standard(proto: "file_import_response"),
    6: .standard(proto: "function_call_response"),
    7: .standard(proto: "version_request"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: Sass_EmbeddedProtocol_InboundMessage.CompileRequest?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .compileRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .compileRequest(v)
        }
      }()
      case 3: try {
        var v: Sass_EmbeddedProtocol_InboundMessage.CanonicalizeResponse?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .canonicalizeResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .canonicalizeResponse(v)
        }
      }()
      case 4: try {
        var v: Sass_EmbeddedProtocol_InboundMessage.ImportResponse?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .importResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .importResponse(v)
        }
      }()
      case 5: try {
        var v: Sass_EmbeddedProtocol_InboundMessage.FileImportResponse?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .fileImportResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .fileImportResponse(v)
        }
      }()
      case 6: try {
        var v: Sass_EmbeddedProtocol_InboundMessage.FunctionCallResponse?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .functionCallResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .functionCallResponse(v)
        }
      }()
      case 7: try {
        var v: Sass_EmbeddedProtocol_InboundMessage.VersionRequest?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .versionRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .versionRequest(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.message {
    case .compileRequest?: try {
      guard case .compileRequest(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .canonicalizeResponse?: try {
      guard case .canonicalizeResponse(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .importResponse?: try {
      guard case .importResponse(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .fileImportResponse?: try {
      guard case .fileImportResponse(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .functionCallResponse?: try {
      guard case .functionCallResponse(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .versionRequest?: try {
      guard case .versionRequest(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_InboundMessage, rhs: Sass_EmbeddedProtocol_InboundMessage) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_InboundMessage.VersionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_InboundMessage.protoMessageName + ".VersionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_InboundMessage.VersionRequest, rhs: Sass_EmbeddedProtocol_InboundMessage.VersionRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_InboundMessage.CompileRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_InboundMessage.protoMessageName + ".CompileRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "string"),
    3: .same(proto: "path"),
    4: .same(proto: "style"),
    5: .standard(proto: "source_map"),
    6: .same(proto: "importers"),
    7: .standard(proto: "global_functions"),
    8: .standard(proto: "alert_color"),
    9: .standard(proto: "alert_ascii"),
    10: .same(proto: "verbose"),
    11: .standard(proto: "quiet_deps"),
    12: .standard(proto: "source_map_include_sources"),
    13: .same(proto: "charset"),
    14: .same(proto: "silent"),
    15: .standard(proto: "fatal_deprecation"),
    16: .standard(proto: "silence_deprecation"),
    17: .standard(proto: "future_deprecation"),
  ]

  fileprivate class _StorageClass {
    var _input: Sass_EmbeddedProtocol_InboundMessage.CompileRequest.OneOf_Input?
    var _style: Sass_EmbeddedProtocol_OutputStyle = .expanded
    var _sourceMap: Bool = false
    var _importers: [Sass_EmbeddedProtocol_InboundMessage.CompileRequest.Importer] = []
    var _globalFunctions: [String] = []
    var _alertColor: Bool = false
    var _alertAscii: Bool = false
    var _verbose: Bool = false
    var _quietDeps: Bool = false
    var _sourceMapIncludeSources: Bool = false
    var _charset: Bool = false
    var _silent: Bool = false
    var _fatalDeprecation: [String] = []
    var _silenceDeprecation: [String] = []
    var _futureDeprecation: [String] = []

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _input = source._input
      _style = source._style
      _sourceMap = source._sourceMap
      _importers = source._importers
      _globalFunctions = source._globalFunctions
      _alertColor = source._alertColor
      _alertAscii = source._alertAscii
      _verbose = source._verbose
      _quietDeps = source._quietDeps
      _sourceMapIncludeSources = source._sourceMapIncludeSources
      _charset = source._charset
      _silent = source._silent
      _fatalDeprecation = source._fatalDeprecation
      _silenceDeprecation = source._silenceDeprecation
      _futureDeprecation = source._futureDeprecation
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 2: try {
          var v: Sass_EmbeddedProtocol_InboundMessage.CompileRequest.StringInput?
          var hadOneofValue = false
          if let current = _storage._input {
            hadOneofValue = true
            if case .string(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._input = .string(v)
          }
        }()
        case 3: try {
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {
            if _storage._input != nil {try decoder.handleConflictingOneOf()}
            _storage._input = .path(v)
          }
        }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._style) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._sourceMap) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._importers) }()
        case 7: try { try decoder.decodeRepeatedStringField(value: &_storage._globalFunctions) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._alertColor) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._alertAscii) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._verbose) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._quietDeps) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._sourceMapIncludeSources) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._charset) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._silent) }()
        case 15: try { try decoder.decodeRepeatedStringField(value: &_storage._fatalDeprecation) }()
        case 16: try { try decoder.decodeRepeatedStringField(value: &_storage._silenceDeprecation) }()
        case 17: try { try decoder.decodeRepeatedStringField(value: &_storage._futureDeprecation) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      switch _storage._input {
      case .string?: try {
        guard case .string(let v)? = _storage._input else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }()
      case .path?: try {
        guard case .path(let v)? = _storage._input else { preconditionFailure() }
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      }()
      case nil: break
      }
      if _storage._style != .expanded {
        try visitor.visitSingularEnumField(value: _storage._style, fieldNumber: 4)
      }
      if _storage._sourceMap != false {
        try visitor.visitSingularBoolField(value: _storage._sourceMap, fieldNumber: 5)
      }
      if !_storage._importers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._importers, fieldNumber: 6)
      }
      if !_storage._globalFunctions.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._globalFunctions, fieldNumber: 7)
      }
      if _storage._alertColor != false {
        try visitor.visitSingularBoolField(value: _storage._alertColor, fieldNumber: 8)
      }
      if _storage._alertAscii != false {
        try visitor.visitSingularBoolField(value: _storage._alertAscii, fieldNumber: 9)
      }
      if _storage._verbose != false {
        try visitor.visitSingularBoolField(value: _storage._verbose, fieldNumber: 10)
      }
      if _storage._quietDeps != false {
        try visitor.visitSingularBoolField(value: _storage._quietDeps, fieldNumber: 11)
      }
      if _storage._sourceMapIncludeSources != false {
        try visitor.visitSingularBoolField(value: _storage._sourceMapIncludeSources, fieldNumber: 12)
      }
      if _storage._charset != false {
        try visitor.visitSingularBoolField(value: _storage._charset, fieldNumber: 13)
      }
      if _storage._silent != false {
        try visitor.visitSingularBoolField(value: _storage._silent, fieldNumber: 14)
      }
      if !_storage._fatalDeprecation.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._fatalDeprecation, fieldNumber: 15)
      }
      if !_storage._silenceDeprecation.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._silenceDeprecation, fieldNumber: 16)
      }
      if !_storage._futureDeprecation.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._futureDeprecation, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_InboundMessage.CompileRequest, rhs: Sass_EmbeddedProtocol_InboundMessage.CompileRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._input != rhs_storage._input {return false}
        if _storage._style != rhs_storage._style {return false}
        if _storage._sourceMap != rhs_storage._sourceMap {return false}
        if _storage._importers != rhs_storage._importers {return false}
        if _storage._globalFunctions != rhs_storage._globalFunctions {return false}
        if _storage._alertColor != rhs_storage._alertColor {return false}
        if _storage._alertAscii != rhs_storage._alertAscii {return false}
        if _storage._verbose != rhs_storage._verbose {return false}
        if _storage._quietDeps != rhs_storage._quietDeps {return false}
        if _storage._sourceMapIncludeSources != rhs_storage._sourceMapIncludeSources {return false}
        if _storage._charset != rhs_storage._charset {return false}
        if _storage._silent != rhs_storage._silent {return false}
        if _storage._fatalDeprecation != rhs_storage._fatalDeprecation {return false}
        if _storage._silenceDeprecation != rhs_storage._silenceDeprecation {return false}
        if _storage._futureDeprecation != rhs_storage._futureDeprecation {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_InboundMessage.CompileRequest.StringInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_InboundMessage.CompileRequest.protoMessageName + ".StringInput"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
    2: .same(proto: "url"),
    3: .same(proto: "syntax"),
    4: .same(proto: "importer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.source) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.syntax) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._importer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.source.isEmpty {
      try visitor.visitSingularStringField(value: self.source, fieldNumber: 1)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 2)
    }
    if self.syntax != .scss {
      try visitor.visitSingularEnumField(value: self.syntax, fieldNumber: 3)
    }
    try { if let v = self._importer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_InboundMessage.CompileRequest.StringInput, rhs: Sass_EmbeddedProtocol_InboundMessage.CompileRequest.StringInput) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.url != rhs.url {return false}
    if lhs.syntax != rhs.syntax {return false}
    if lhs._importer != rhs._importer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_InboundMessage.CompileRequest.Importer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_InboundMessage.CompileRequest.protoMessageName + ".Importer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .standard(proto: "importer_id"),
    3: .standard(proto: "file_importer_id"),
    5: .standard(proto: "node_package_importer"),
    4: .standard(proto: "non_canonical_scheme"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.importer != nil {try decoder.handleConflictingOneOf()}
          self.importer = .path(v)
        }
      }()
      case 2: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.importer != nil {try decoder.handleConflictingOneOf()}
          self.importer = .importerID(v)
        }
      }()
      case 3: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.importer != nil {try decoder.handleConflictingOneOf()}
          self.importer = .fileImporterID(v)
        }
      }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.nonCanonicalScheme) }()
      case 5: try {
        var v: Sass_EmbeddedProtocol_NodePackageImporter?
        var hadOneofValue = false
        if let current = self.importer {
          hadOneofValue = true
          if case .nodePackageImporter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.importer = .nodePackageImporter(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.importer {
    case .path?: try {
      guard case .path(let v)? = self.importer else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .importerID?: try {
      guard case .importerID(let v)? = self.importer else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }()
    case .fileImporterID?: try {
      guard case .fileImporterID(let v)? = self.importer else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }()
    default: break
    }
    if !self.nonCanonicalScheme.isEmpty {
      try visitor.visitRepeatedStringField(value: self.nonCanonicalScheme, fieldNumber: 4)
    }
    try { if case .nodePackageImporter(let v)? = self.importer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_InboundMessage.CompileRequest.Importer, rhs: Sass_EmbeddedProtocol_InboundMessage.CompileRequest.Importer) -> Bool {
    if lhs.importer != rhs.importer {return false}
    if lhs.nonCanonicalScheme != rhs.nonCanonicalScheme {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_InboundMessage.CanonicalizeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_InboundMessage.protoMessageName + ".CanonicalizeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "url"),
    3: .same(proto: "error"),
    4: .standard(proto: "containing_url_unused"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.result != nil {try decoder.handleConflictingOneOf()}
          self.result = .url(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.result != nil {try decoder.handleConflictingOneOf()}
          self.result = .error(v)
        }
      }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.containingURLUnused) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    switch self.result {
    case .url?: try {
      guard case .url(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .error?: try {
      guard case .error(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if self.containingURLUnused != false {
      try visitor.visitSingularBoolField(value: self.containingURLUnused, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_InboundMessage.CanonicalizeResponse, rhs: Sass_EmbeddedProtocol_InboundMessage.CanonicalizeResponse) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.result != rhs.result {return false}
    if lhs.containingURLUnused != rhs.containingURLUnused {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_InboundMessage.ImportResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_InboundMessage.protoMessageName + ".ImportResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "success"),
    3: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      case 2: try {
        var v: Sass_EmbeddedProtocol_InboundMessage.ImportResponse.ImportSuccess?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .success(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .success(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.result != nil {try decoder.handleConflictingOneOf()}
          self.result = .error(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    switch self.result {
    case .success?: try {
      guard case .success(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .error?: try {
      guard case .error(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_InboundMessage.ImportResponse, rhs: Sass_EmbeddedProtocol_InboundMessage.ImportResponse) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_InboundMessage.ImportResponse.ImportSuccess: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_InboundMessage.ImportResponse.protoMessageName + ".ImportSuccess"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contents"),
    2: .same(proto: "syntax"),
    3: .standard(proto: "source_map_url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contents) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.syntax) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._sourceMapURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.contents.isEmpty {
      try visitor.visitSingularStringField(value: self.contents, fieldNumber: 1)
    }
    if self.syntax != .scss {
      try visitor.visitSingularEnumField(value: self.syntax, fieldNumber: 2)
    }
    try { if let v = self._sourceMapURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_InboundMessage.ImportResponse.ImportSuccess, rhs: Sass_EmbeddedProtocol_InboundMessage.ImportResponse.ImportSuccess) -> Bool {
    if lhs.contents != rhs.contents {return false}
    if lhs.syntax != rhs.syntax {return false}
    if lhs._sourceMapURL != rhs._sourceMapURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_InboundMessage.FileImportResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_InboundMessage.protoMessageName + ".FileImportResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "file_url"),
    3: .same(proto: "error"),
    4: .standard(proto: "containing_url_unused"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.result != nil {try decoder.handleConflictingOneOf()}
          self.result = .fileURL(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.result != nil {try decoder.handleConflictingOneOf()}
          self.result = .error(v)
        }
      }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.containingURLUnused) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    switch self.result {
    case .fileURL?: try {
      guard case .fileURL(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .error?: try {
      guard case .error(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if self.containingURLUnused != false {
      try visitor.visitSingularBoolField(value: self.containingURLUnused, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_InboundMessage.FileImportResponse, rhs: Sass_EmbeddedProtocol_InboundMessage.FileImportResponse) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.result != rhs.result {return false}
    if lhs.containingURLUnused != rhs.containingURLUnused {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_InboundMessage.FunctionCallResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_InboundMessage.protoMessageName + ".FunctionCallResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "success"),
    3: .same(proto: "error"),
    4: .standard(proto: "accessed_argument_lists"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      case 2: try {
        var v: Sass_EmbeddedProtocol_Value?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .success(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .success(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.result != nil {try decoder.handleConflictingOneOf()}
          self.result = .error(v)
        }
      }()
      case 4: try { try decoder.decodeRepeatedUInt32Field(value: &self.accessedArgumentLists) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    switch self.result {
    case .success?: try {
      guard case .success(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .error?: try {
      guard case .error(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if !self.accessedArgumentLists.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.accessedArgumentLists, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_InboundMessage.FunctionCallResponse, rhs: Sass_EmbeddedProtocol_InboundMessage.FunctionCallResponse) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.result != rhs.result {return false}
    if lhs.accessedArgumentLists != rhs.accessedArgumentLists {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_OutboundMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OutboundMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .standard(proto: "compile_response"),
    3: .standard(proto: "log_event"),
    4: .standard(proto: "canonicalize_request"),
    5: .standard(proto: "import_request"),
    6: .standard(proto: "file_import_request"),
    7: .standard(proto: "function_call_request"),
    8: .standard(proto: "version_response"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Sass_EmbeddedProtocol_ProtocolError?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .error(v)
        }
      }()
      case 2: try {
        var v: Sass_EmbeddedProtocol_OutboundMessage.CompileResponse?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .compileResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .compileResponse(v)
        }
      }()
      case 3: try {
        var v: Sass_EmbeddedProtocol_OutboundMessage.LogEvent?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .logEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .logEvent(v)
        }
      }()
      case 4: try {
        var v: Sass_EmbeddedProtocol_OutboundMessage.CanonicalizeRequest?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .canonicalizeRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .canonicalizeRequest(v)
        }
      }()
      case 5: try {
        var v: Sass_EmbeddedProtocol_OutboundMessage.ImportRequest?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .importRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .importRequest(v)
        }
      }()
      case 6: try {
        var v: Sass_EmbeddedProtocol_OutboundMessage.FileImportRequest?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .fileImportRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .fileImportRequest(v)
        }
      }()
      case 7: try {
        var v: Sass_EmbeddedProtocol_OutboundMessage.FunctionCallRequest?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .functionCallRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .functionCallRequest(v)
        }
      }()
      case 8: try {
        var v: Sass_EmbeddedProtocol_OutboundMessage.VersionResponse?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .versionResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .versionResponse(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.message {
    case .error?: try {
      guard case .error(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .compileResponse?: try {
      guard case .compileResponse(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .logEvent?: try {
      guard case .logEvent(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .canonicalizeRequest?: try {
      guard case .canonicalizeRequest(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .importRequest?: try {
      guard case .importRequest(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .fileImportRequest?: try {
      guard case .fileImportRequest(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .functionCallRequest?: try {
      guard case .functionCallRequest(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .versionResponse?: try {
      guard case .versionResponse(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_OutboundMessage, rhs: Sass_EmbeddedProtocol_OutboundMessage) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_OutboundMessage.VersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_OutboundMessage.protoMessageName + ".VersionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .same(proto: "id"),
    1: .standard(proto: "protocol_version"),
    2: .standard(proto: "compiler_version"),
    3: .standard(proto: "implementation_version"),
    4: .standard(proto: "implementation_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.protocolVersion) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.compilerVersion) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.implementationVersion) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.implementationName) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.protocolVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.protocolVersion, fieldNumber: 1)
    }
    if !self.compilerVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.compilerVersion, fieldNumber: 2)
    }
    if !self.implementationVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.implementationVersion, fieldNumber: 3)
    }
    if !self.implementationName.isEmpty {
      try visitor.visitSingularStringField(value: self.implementationName, fieldNumber: 4)
    }
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_OutboundMessage.VersionResponse, rhs: Sass_EmbeddedProtocol_OutboundMessage.VersionResponse) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.protocolVersion != rhs.protocolVersion {return false}
    if lhs.compilerVersion != rhs.compilerVersion {return false}
    if lhs.implementationVersion != rhs.implementationVersion {return false}
    if lhs.implementationName != rhs.implementationName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_OutboundMessage.CompileResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_OutboundMessage.protoMessageName + ".CompileResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "success"),
    3: .same(proto: "failure"),
    4: .standard(proto: "loaded_urls"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: Sass_EmbeddedProtocol_OutboundMessage.CompileResponse.CompileSuccess?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .success(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .success(v)
        }
      }()
      case 3: try {
        var v: Sass_EmbeddedProtocol_OutboundMessage.CompileResponse.CompileFailure?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .failure(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .failure(v)
        }
      }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.loadedUrls) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.result {
    case .success?: try {
      guard case .success(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .failure?: try {
      guard case .failure(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if !self.loadedUrls.isEmpty {
      try visitor.visitRepeatedStringField(value: self.loadedUrls, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_OutboundMessage.CompileResponse, rhs: Sass_EmbeddedProtocol_OutboundMessage.CompileResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.loadedUrls != rhs.loadedUrls {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_OutboundMessage.CompileResponse.CompileSuccess: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_OutboundMessage.CompileResponse.protoMessageName + ".CompileSuccess"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "css"),
    2: .standard(proto: "source_map"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.css) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sourceMap) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.css.isEmpty {
      try visitor.visitSingularStringField(value: self.css, fieldNumber: 1)
    }
    if !self.sourceMap.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceMap, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_OutboundMessage.CompileResponse.CompileSuccess, rhs: Sass_EmbeddedProtocol_OutboundMessage.CompileResponse.CompileSuccess) -> Bool {
    if lhs.css != rhs.css {return false}
    if lhs.sourceMap != rhs.sourceMap {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_OutboundMessage.CompileResponse.CompileFailure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_OutboundMessage.CompileResponse.protoMessageName + ".CompileFailure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
    2: .same(proto: "span"),
    3: .standard(proto: "stack_trace"),
    4: .same(proto: "formatted"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._span) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.stackTrace) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.formatted) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try { if let v = self._span {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.stackTrace.isEmpty {
      try visitor.visitSingularStringField(value: self.stackTrace, fieldNumber: 3)
    }
    if !self.formatted.isEmpty {
      try visitor.visitSingularStringField(value: self.formatted, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_OutboundMessage.CompileResponse.CompileFailure, rhs: Sass_EmbeddedProtocol_OutboundMessage.CompileResponse.CompileFailure) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs._span != rhs._span {return false}
    if lhs.stackTrace != rhs.stackTrace {return false}
    if lhs.formatted != rhs.formatted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_OutboundMessage.LogEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_OutboundMessage.protoMessageName + ".LogEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "type"),
    3: .same(proto: "message"),
    4: .same(proto: "span"),
    5: .standard(proto: "stack_trace"),
    6: .same(proto: "formatted"),
    7: .standard(proto: "deprecation_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._span) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.stackTrace) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.formatted) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._deprecationType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .warning {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 3)
    }
    try { if let v = self._span {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.stackTrace.isEmpty {
      try visitor.visitSingularStringField(value: self.stackTrace, fieldNumber: 5)
    }
    if !self.formatted.isEmpty {
      try visitor.visitSingularStringField(value: self.formatted, fieldNumber: 6)
    }
    try { if let v = self._deprecationType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_OutboundMessage.LogEvent, rhs: Sass_EmbeddedProtocol_OutboundMessage.LogEvent) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.message != rhs.message {return false}
    if lhs._span != rhs._span {return false}
    if lhs.stackTrace != rhs.stackTrace {return false}
    if lhs.formatted != rhs.formatted {return false}
    if lhs._deprecationType != rhs._deprecationType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_OutboundMessage.CanonicalizeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_OutboundMessage.protoMessageName + ".CanonicalizeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    3: .standard(proto: "importer_id"),
    4: .same(proto: "url"),
    5: .standard(proto: "from_import"),
    6: .standard(proto: "containing_url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.importerID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.fromImport) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._containingURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    if self.importerID != 0 {
      try visitor.visitSingularUInt32Field(value: self.importerID, fieldNumber: 3)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 4)
    }
    if self.fromImport != false {
      try visitor.visitSingularBoolField(value: self.fromImport, fieldNumber: 5)
    }
    try { if let v = self._containingURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_OutboundMessage.CanonicalizeRequest, rhs: Sass_EmbeddedProtocol_OutboundMessage.CanonicalizeRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.importerID != rhs.importerID {return false}
    if lhs.url != rhs.url {return false}
    if lhs.fromImport != rhs.fromImport {return false}
    if lhs._containingURL != rhs._containingURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_OutboundMessage.ImportRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_OutboundMessage.protoMessageName + ".ImportRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    3: .standard(proto: "importer_id"),
    4: .same(proto: "url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.importerID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    if self.importerID != 0 {
      try visitor.visitSingularUInt32Field(value: self.importerID, fieldNumber: 3)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_OutboundMessage.ImportRequest, rhs: Sass_EmbeddedProtocol_OutboundMessage.ImportRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.importerID != rhs.importerID {return false}
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_OutboundMessage.FileImportRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_OutboundMessage.protoMessageName + ".FileImportRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    3: .standard(proto: "importer_id"),
    4: .same(proto: "url"),
    5: .standard(proto: "from_import"),
    6: .standard(proto: "containing_url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.importerID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.fromImport) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._containingURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    if self.importerID != 0 {
      try visitor.visitSingularUInt32Field(value: self.importerID, fieldNumber: 3)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 4)
    }
    if self.fromImport != false {
      try visitor.visitSingularBoolField(value: self.fromImport, fieldNumber: 5)
    }
    try { if let v = self._containingURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_OutboundMessage.FileImportRequest, rhs: Sass_EmbeddedProtocol_OutboundMessage.FileImportRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.importerID != rhs.importerID {return false}
    if lhs.url != rhs.url {return false}
    if lhs.fromImport != rhs.fromImport {return false}
    if lhs._containingURL != rhs._containingURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_OutboundMessage.FunctionCallRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_OutboundMessage.protoMessageName + ".FunctionCallRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    3: .same(proto: "name"),
    4: .standard(proto: "function_id"),
    5: .same(proto: "arguments"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.identifier != nil {try decoder.handleConflictingOneOf()}
          self.identifier = .name(v)
        }
      }()
      case 4: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.identifier != nil {try decoder.handleConflictingOneOf()}
          self.identifier = .functionID(v)
        }
      }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.arguments) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    switch self.identifier {
    case .name?: try {
      guard case .name(let v)? = self.identifier else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case .functionID?: try {
      guard case .functionID(let v)? = self.identifier else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    if !self.arguments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.arguments, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_OutboundMessage.FunctionCallRequest, rhs: Sass_EmbeddedProtocol_OutboundMessage.FunctionCallRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.identifier != rhs.identifier {return false}
    if lhs.arguments != rhs.arguments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_ProtocolError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProtocolError"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "id"),
    3: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .parse {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 2)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_ProtocolError, rhs: Sass_EmbeddedProtocol_ProtocolError) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.id != rhs.id {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_SourceSpan: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SourceSpan"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "start"),
    3: .same(proto: "end"),
    4: .same(proto: "url"),
    5: .same(proto: "context"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._start) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._end) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.context) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    try { if let v = self._start {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._end {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 4)
    }
    if !self.context.isEmpty {
      try visitor.visitSingularStringField(value: self.context, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_SourceSpan, rhs: Sass_EmbeddedProtocol_SourceSpan) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs._start != rhs._start {return false}
    if lhs._end != rhs._end {return false}
    if lhs.url != rhs.url {return false}
    if lhs.context != rhs.context {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_SourceSpan.SourceLocation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_SourceSpan.protoMessageName + ".SourceLocation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "offset"),
    2: .same(proto: "line"),
    3: .same(proto: "column"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.offset) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.line) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.column) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.offset != 0 {
      try visitor.visitSingularUInt32Field(value: self.offset, fieldNumber: 1)
    }
    if self.line != 0 {
      try visitor.visitSingularUInt32Field(value: self.line, fieldNumber: 2)
    }
    if self.column != 0 {
      try visitor.visitSingularUInt32Field(value: self.column, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_SourceSpan.SourceLocation, rhs: Sass_EmbeddedProtocol_SourceSpan.SourceLocation) -> Bool {
    if lhs.offset != rhs.offset {return false}
    if lhs.line != rhs.line {return false}
    if lhs.column != rhs.column {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_Value: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Value"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "string"),
    2: .same(proto: "number"),
    5: .same(proto: "list"),
    6: .same(proto: "map"),
    7: .same(proto: "singleton"),
    8: .standard(proto: "compiler_function"),
    9: .standard(proto: "host_function"),
    10: .standard(proto: "argument_list"),
    12: .same(proto: "calculation"),
    13: .standard(proto: "compiler_mixin"),
    14: .same(proto: "color"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Sass_EmbeddedProtocol_Value.StringMessage?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .string(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .string(v)
        }
      }()
      case 2: try {
        var v: Sass_EmbeddedProtocol_Value.Number?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .number(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .number(v)
        }
      }()
      case 5: try {
        var v: Sass_EmbeddedProtocol_Value.List?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .list(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .list(v)
        }
      }()
      case 6: try {
        var v: Sass_EmbeddedProtocol_Value.Map?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .map(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .map(v)
        }
      }()
      case 7: try {
        var v: Sass_EmbeddedProtocol_SingletonValue?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .singleton(v)
        }
      }()
      case 8: try {
        var v: Sass_EmbeddedProtocol_Value.CompilerFunction?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .compilerFunction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .compilerFunction(v)
        }
      }()
      case 9: try {
        var v: Sass_EmbeddedProtocol_Value.HostFunction?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .hostFunction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .hostFunction(v)
        }
      }()
      case 10: try {
        var v: Sass_EmbeddedProtocol_Value.ArgumentList?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .argumentList(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .argumentList(v)
        }
      }()
      case 12: try {
        var v: Sass_EmbeddedProtocol_Value.Calculation?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .calculation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .calculation(v)
        }
      }()
      case 13: try {
        var v: Sass_EmbeddedProtocol_Value.CompilerMixin?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .compilerMixin(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .compilerMixin(v)
        }
      }()
      case 14: try {
        var v: Sass_EmbeddedProtocol_Value.Color?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .color(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .color(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.value {
    case .string?: try {
      guard case .string(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .number?: try {
      guard case .number(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .list?: try {
      guard case .list(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .map?: try {
      guard case .map(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .singleton?: try {
      guard case .singleton(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 7)
    }()
    case .compilerFunction?: try {
      guard case .compilerFunction(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .hostFunction?: try {
      guard case .hostFunction(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .argumentList?: try {
      guard case .argumentList(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .calculation?: try {
      guard case .calculation(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .compilerMixin?: try {
      guard case .compilerMixin(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .color?: try {
      guard case .color(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_Value, rhs: Sass_EmbeddedProtocol_Value) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_Value.StringMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_Value.protoMessageName + ".String"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "quoted"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.quoted) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    if self.quoted != false {
      try visitor.visitSingularBoolField(value: self.quoted, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_Value.StringMessage, rhs: Sass_EmbeddedProtocol_Value.StringMessage) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.quoted != rhs.quoted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_Value.Number: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_Value.protoMessageName + ".Number"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "numerators"),
    3: .same(proto: "denominators"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.value) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.numerators) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.denominators) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.value, fieldNumber: 1)
    }
    if !self.numerators.isEmpty {
      try visitor.visitRepeatedStringField(value: self.numerators, fieldNumber: 2)
    }
    if !self.denominators.isEmpty {
      try visitor.visitRepeatedStringField(value: self.denominators, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_Value.Number, rhs: Sass_EmbeddedProtocol_Value.Number) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.numerators != rhs.numerators {return false}
    if lhs.denominators != rhs.denominators {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_Value.Color: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_Value.protoMessageName + ".Color"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "space"),
    2: .same(proto: "channel1"),
    3: .same(proto: "channel2"),
    4: .same(proto: "channel3"),
    5: .same(proto: "alpha"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.space) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self._channel1) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self._channel2) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self._channel3) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self._alpha) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.space.isEmpty {
      try visitor.visitSingularStringField(value: self.space, fieldNumber: 1)
    }
    try { if let v = self._channel1 {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._channel2 {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._channel3 {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._alpha {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_Value.Color, rhs: Sass_EmbeddedProtocol_Value.Color) -> Bool {
    if lhs.space != rhs.space {return false}
    if lhs._channel1 != rhs._channel1 {return false}
    if lhs._channel2 != rhs._channel2 {return false}
    if lhs._channel3 != rhs._channel3 {return false}
    if lhs._alpha != rhs._alpha {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_Value.List: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_Value.protoMessageName + ".List"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "separator"),
    2: .standard(proto: "has_brackets"),
    3: .same(proto: "contents"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.separator) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.hasBrackets_p) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.contents) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.separator != .comma {
      try visitor.visitSingularEnumField(value: self.separator, fieldNumber: 1)
    }
    if self.hasBrackets_p != false {
      try visitor.visitSingularBoolField(value: self.hasBrackets_p, fieldNumber: 2)
    }
    if !self.contents.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.contents, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_Value.List, rhs: Sass_EmbeddedProtocol_Value.List) -> Bool {
    if lhs.separator != rhs.separator {return false}
    if lhs.hasBrackets_p != rhs.hasBrackets_p {return false}
    if lhs.contents != rhs.contents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_Value.Map: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_Value.protoMessageName + ".Map"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entries"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_Value.Map, rhs: Sass_EmbeddedProtocol_Value.Map) -> Bool {
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_Value.Map.Entry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_Value.Map.protoMessageName + ".Entry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._key) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._key {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_Value.Map.Entry, rhs: Sass_EmbeddedProtocol_Value.Map.Entry) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_Value.CompilerFunction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_Value.protoMessageName + ".CompilerFunction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_Value.CompilerFunction, rhs: Sass_EmbeddedProtocol_Value.CompilerFunction) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_Value.HostFunction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_Value.protoMessageName + ".HostFunction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.signature) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularStringField(value: self.signature, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_Value.HostFunction, rhs: Sass_EmbeddedProtocol_Value.HostFunction) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_Value.CompilerMixin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_Value.protoMessageName + ".CompilerMixin"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_Value.CompilerMixin, rhs: Sass_EmbeddedProtocol_Value.CompilerMixin) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_Value.ArgumentList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_Value.protoMessageName + ".ArgumentList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "separator"),
    3: .same(proto: "contents"),
    4: .same(proto: "keywords"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.separator) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.contents) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Sass_EmbeddedProtocol_Value>.self, value: &self.keywords) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    if self.separator != .comma {
      try visitor.visitSingularEnumField(value: self.separator, fieldNumber: 2)
    }
    if !self.contents.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.contents, fieldNumber: 3)
    }
    if !self.keywords.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Sass_EmbeddedProtocol_Value>.self, value: self.keywords, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_Value.ArgumentList, rhs: Sass_EmbeddedProtocol_Value.ArgumentList) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.separator != rhs.separator {return false}
    if lhs.contents != rhs.contents {return false}
    if lhs.keywords != rhs.keywords {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_Value.Calculation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_Value.protoMessageName + ".Calculation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "arguments"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.arguments) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.arguments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.arguments, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_Value.Calculation, rhs: Sass_EmbeddedProtocol_Value.Calculation) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.arguments != rhs.arguments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_Value.Calculation.CalculationValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_Value.Calculation.protoMessageName + ".CalculationValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "number"),
    2: .same(proto: "string"),
    3: .same(proto: "interpolation"),
    4: .same(proto: "operation"),
    5: .same(proto: "calculation"),
  ]

  fileprivate class _StorageClass {
    var _value: Sass_EmbeddedProtocol_Value.Calculation.CalculationValue.OneOf_Value?

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _value = source._value
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try {
          var v: Sass_EmbeddedProtocol_Value.Number?
          var hadOneofValue = false
          if let current = _storage._value {
            hadOneofValue = true
            if case .number(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._value = .number(v)
          }
        }()
        case 2: try {
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {
            if _storage._value != nil {try decoder.handleConflictingOneOf()}
            _storage._value = .string(v)
          }
        }()
        case 3: try {
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {
            if _storage._value != nil {try decoder.handleConflictingOneOf()}
            _storage._value = .interpolation(v)
          }
        }()
        case 4: try {
          var v: Sass_EmbeddedProtocol_Value.Calculation.CalculationOperation?
          var hadOneofValue = false
          if let current = _storage._value {
            hadOneofValue = true
            if case .operation(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._value = .operation(v)
          }
        }()
        case 5: try {
          var v: Sass_EmbeddedProtocol_Value.Calculation?
          var hadOneofValue = false
          if let current = _storage._value {
            hadOneofValue = true
            if case .calculation(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._value = .calculation(v)
          }
        }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      switch _storage._value {
      case .number?: try {
        guard case .number(let v)? = _storage._value else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }()
      case .string?: try {
        guard case .string(let v)? = _storage._value else { preconditionFailure() }
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }()
      case .interpolation?: try {
        guard case .interpolation(let v)? = _storage._value else { preconditionFailure() }
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      }()
      case .operation?: try {
        guard case .operation(let v)? = _storage._value else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .calculation?: try {
        guard case .calculation(let v)? = _storage._value else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_Value.Calculation.CalculationValue, rhs: Sass_EmbeddedProtocol_Value.Calculation.CalculationValue) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._value != rhs_storage._value {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_Value.Calculation.CalculationOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sass_EmbeddedProtocol_Value.Calculation.protoMessageName + ".CalculationOperation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operator"),
    2: .same(proto: "left"),
    3: .same(proto: "right"),
  ]

  fileprivate class _StorageClass {
    var _operator: Sass_EmbeddedProtocol_CalculationOperator = .plus
    var _left: Sass_EmbeddedProtocol_Value.Calculation.CalculationValue? = nil
    var _right: Sass_EmbeddedProtocol_Value.Calculation.CalculationValue? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _operator = source._operator
      _left = source._left
      _right = source._right
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._operator) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._left) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._right) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._operator != .plus {
        try visitor.visitSingularEnumField(value: _storage._operator, fieldNumber: 1)
      }
      try { if let v = _storage._left {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._right {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_Value.Calculation.CalculationOperation, rhs: Sass_EmbeddedProtocol_Value.Calculation.CalculationOperation) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._operator != rhs_storage._operator {return false}
        if _storage._left != rhs_storage._left {return false}
        if _storage._right != rhs_storage._right {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sass_EmbeddedProtocol_NodePackageImporter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NodePackageImporter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "entry_point_directory"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.entryPointDirectory) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entryPointDirectory.isEmpty {
      try visitor.visitSingularStringField(value: self.entryPointDirectory, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sass_EmbeddedProtocol_NodePackageImporter, rhs: Sass_EmbeddedProtocol_NodePackageImporter) -> Bool {
    if lhs.entryPointDirectory != rhs.entryPointDirectory {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
